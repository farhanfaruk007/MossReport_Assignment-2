<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/22101610_priota_das_cse422_03_lab_assignment02_fall2024_-_PRIOTA_DAS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/22101610_priota_das_cse422_03_lab_assignment02_fall2024_-_PRIOTA_DAS.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101610_Priota.Das_CSE422_03_Lab_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ioS-lDbTVcwVoHkM-vAUy0Hm96pDrcg
<a name="0"></a><font color="#FF0000"><a href="match22-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_46.gif"/></a>

"""

import math
import random #random number

def penalty_overlap(time,N,T):#calculate paalty of courses on same time
    arr_chk=[] #store time slot
    p_overlap=0
    for p in range(T): #interate each slot
        each_slot=time[p*N:(p+1)*N] #slide binary string
        # print(indivisual_slot)
        count=max(each_slot.count("1")-1,0) #count of overlapping
        p_overlap+=count #add overlap penalty
    return p_overlap #total overlap[ penalty


def panelty_consistency(time,N,T):#calculate if course assing more than 1
    panelty=0

    for p in range(N): #iterate each course
        panelty_count = 0 #count how many time course assine
        for q in range(T):#iterate each slot
            panelty_count+=int(time[q*N+p]) #taike 1 course in one slot
            # print(panelty_count)

        panelty+=abs(panelty_count-1) #if course take several time slot, add penalty
        # print(panelty)
    return panelty

def fitness(time,N,T):#perfect schudle
    panelty= -(penalty_overlap(time,N,T)+panelty_consistency(time,N,T)) #add both penalty o_p+c_p
    return panelty

def population_creation(n,t,p_size):#random population schedules as a binary string

    list_people=[]#each schedules

    for q in range(p_size):
        population = ""
        for r in range(n*t):  #each individual give random binary string len n*t
            population+=random.choice('01')
        # print(population)
        list_people.append(population)
    return list_people

def selection_parent(population):#take two random parents for crossover
    return random.choice(population),random.choice(population)#select two random parents from the population

def cross_over(parent1,parent2,N,T):#creat 2 child
    point=random.randint(0,N*T-1) #select random crossover point in binary
    #crossover
    child1=parent1[0:point]+parent2[point:]#child1 gets 1st part of parent1 and 2nd part of parent2
    child2=parent2[0:point]+parent1[point:]#child2 gets 1st part of parent2 and 2nd part of parent1
    return child1,child2 #return babies *_*

def mutation(child,N,T):
    point=random.randint(1,N*T-1)#select random mutation point
    list1=list(child) #strng to list
    # print(list1)
    if list1[point]=="1": #if bit is 1 flip to 0
        list1[point]="0" #vice versa
    else:
        list1[point]="1"
    return "".join(list1)

def genetic_algo(N,T,p_size,iterations):
    population=population_creation(N,T,p_size)#initial population
    # print(population)
    lowest_fitness=-math.inf#lowest fitness value
    best_slot=None
    for _ in range(iterations):
        new_population=[]# store new population
        for _ in range(p_size//2):#pairs of parents,each pair give two children
            parent1,parent2=selection_parent(population)#select 2 parants
            child1,child2=cross_over(parent1,parent2,N,T)#crossover to create two children
            new_population.extend([mutation(child1,N,T),mutation(child2,N,T)])#mutate the children and add them to the new population
        population=new_population
        for slots in population:
            fitess_value=fitness(slots,N,T) #calculate fitness

            if fitess_value&gt;lowest_fitness: # if this individual has a better fitness update that to best shedule
                lowest_fitness = fitess_value
                best_slot = slots

            if lowest_fitness==0: # if perfect solution is found stop
                break
    return lowest_fitness,best_slot


N,T=int(input("Enter Num_of_Courses: ")),int(input("Enter TimeSlots:"))
courses=[input("Enter courses: ") for i in range(N)]
if T&lt;N: # check if no.of time slots &lt; no. of cours
    print("TimeSlots can't be less than Num_of_Courses")
else:
    fitnes,schedule=genetic_algo(N,T,p_size=100,iterations=1000)
    print(schedule)
    print(fitnes)
</font>
import math
import random
def overlap_penalty(time_slots,N,T):
    cheack_arr=[]
    overlap_P=0
    for i in range(T):
        indivisual_slot=time_slots[i*N:(i+1)*N]
        # print(indivisual_slot)
        count=max(indivisual_slot.count("1")-1,0)
        overlap_P+=count
    return overlap_P
<a name="2"></a><font color="#0000FF"><a href="match22-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

def consistency_panelty(time_slots,N,T):
    panelty=0

    for i in range(N):
        panelty_count = 0
        for j in range(T):
            panelty_count+=int(time_slots[j*N+i])
            # print(panelty_count)
            # panelty-=1

        panelty+=abs(panelty_count-1)
        # print(panelty)
    return panelty

def calculate_fitness(time_slots,N,T):
</font>    panelty= -(overlap_penalty(time_slots,N,T)+consistency_panelty(time_slots,N,T))
    return panelty
def create_population(n,t,population_size):
    population_list=[]

    for j in range(population_size):
        population = ""
        for i in range(n*t):
            population+=random.choice('01')
        # print(population)
        population_list.append(population)
    return population_list
def parents_selection(population):
    return random.choice(population),random.choice(population)
def crossover(parent1,parent2,N,T):
    point=random.randint(0,N*T-2)
    point2=random.randint(point+1,N*T-1)
    child1=parent1[0:point]+parent2[point:point2]+parent1[point2:]
    child2=parent2[0:point]+parent1[point:point2]+parent2[point2:]
    return child1,child2
def mutation(child,N,T):
    point=random.randint(1,N*T-1)

    list1=list(child)
    # print(list1)
    if list1[point]=="1":
        list1[point]="0"
    else:
<a name="4"></a><font color="#FF00FF"><a href="match22-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        list1[point]="1"
    return "".join(list1)

def genetic_algo(N,T,population_size,iterations):
    population=create_population(N,T,population_size)
    # print(population)
    lowest_fitness=-math.inf
</font>    best_slot=None
    for _ in range(iterations):
        new_population=[]
        for _ in range(population_size//2):
<a name="1"></a><font color="#00FF00"><a href="match22-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

            parent1,parent2=parents_selection(population)
            child1,child2=crossover(parent1,parent2,N,T)
            new_population.extend([mutation(child1,N,T),mutation(child2,N,T)])
        population=new_population
        for slots in population:
            fitess_value=calculate_fitness(slots,N,T)

            if fitess_value&gt;lowest_fitness:
                lowest_fitness = fitess_value
                best_slot = slots

            if lowest_fitness==0:
                break
    return lowest_fitness,best_slot


N,T=int(input("Enter Num_of_Courses: ")),int(input("Enter TimeSlots:"))
</font><a name="3"></a><font color="#00FFFF"><a href="match22-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

courses=[input("Enter courses: ") for i in range(N)]
if T&lt;N:
    print("TimeSlots can't be less than Num_of_Courses")
else:
    fitness,schedule=genetic_algo(N,T,population_size=100,iterations=1000)
    print(schedule)
    print(fitness)</font></pre>
</body>
</html>
