<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/22101276_musarrat_tasnim_roja_cse422_12_assignment02_fall2024_-_MUSARRAT_TASNIM_ROJA(1).py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/22101276_musarrat_tasnim_roja_cse422_12_assignment02_fall2024_-_MUSARRAT_TASNIM_ROJA(1).py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101276_Musarrat Tasnim Roja_CSE422_12_Assignment02_Fall2024

Automatically generated by Colab.

<a name="0"></a><font color="#FF0000"><a href="match11-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_83.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/1Y5R_V9VEjIkbLzm3gdKAoEht9Y_akw9P
"""

#part1
import random
import numpy as np

def creating_population(N, T, n=10):
    population = []
    count = 0
    while count &lt; n:
        chromosome = ""
        index = 0
        while index &lt; N * T:
            chromosome += str(random.randint(0, 1))
            index += 1
        population.append(chromosome)
        count += 1
    return population

def shuffle_indices(length):

    indices = list(range(length))
    random.shuffle(indices)
    return indices

def parent_choose(population):

    population_size = len(population)
    shuffled_indices = shuffle_indices(population_size)
    return shuffled_indices

def fitnessTest(chromosome, N, T):

    chromosome_array = np.array(list(map(int, chromosome)))

    overlap_penalty = 0
    consistency_tracker = np.zeros(N, dtype=int)

    time_slot = 0
    while time_slot &lt; T:
       segment = chromosome_array[time_slot * N: (time_slot + 1) * N]
       segment_sum = np.sum(segment)
       consistency_tracker += segment
       overlap_penalty += abs(segment_sum - 1)
       time_slot += 1

    consistency_penalty = np.abs(consistency_tracker - 1)
    total_penalty = overlap_penalty + np.sum(consistency_penalty)

    return -total_penalty

def mutate_single_gene(chromosome, index):
    if chromosome[index] == '1':
        return '0'
    else:
        return '1'

def mutatee_chromosome(chromosome, N, T):
    chromosome_list = list(chromosome)
    total_genes = N * T
    mutation_index = random.randint(0, total_genes - 1)
    chromosome_list[mutation_index] = mutate_single_gene(chromosome_list, mutation_index)
    return ''.join(chromosome_list)

def mutatee_offspring(offspring, N, T):
    if random.random() &gt; 0.5:
        return mutatee_chromosome(offspring, N, T)
    return offspring

def mutation(offsprings, N, T):
    offsprings[0] = mutatee_offspring(offsprings[0], N, T)
    offsprings[1] = mutatee_offspring(offsprings[1], N, T)
    return offsprings

def SP_crossover(p1, p2, N, T):
    i = random.randint(1,(N*T)-1)
    return p1[:i]+p2[i:], p2[:i]+p1[i:]

def GeneAlgo(population, N, T):
    population_size = len(population)
    selected_parents = parent_choose(population)
    offspring_list = []

    index = 0
    while index &lt; population_size - 1:
        parent1 = population[selected_parents[index]]
        parent2 = population[selected_parents[index + 1]]

        offsprings = SP_crossover(p1, p2, N, T)
        mutated_offsprings = mutation(list(offsprings), N, T)

        offspring_list.extend(mutated_offsprings)
        index += 2

    population.extend(offspring_list)

    fitness_scores = []
    for chromosome in population:
        fitness = fitnessTest(chromosome, N, T)
        fitness_scores.append((fitness, chromosome))

    fitness_scores.sort(reverse=True)

    new_population = []
    for fitness_pair in fitness_scores[:population_size]:
        new_population.append(fitness_pair[1])

    return new_population

infile = open("input.txt")

N, T = infile.readline().split()
N, T = int(N), int(T)
courses = []
for _ in range(N):
    courses.append(infile.readline().strip())

infile.close()

resultss = creating_population(N, T)
max_iterations = 100
i = 0

with open("output_iterations.txt", "w") as iteration_file:
    while True:
        current_fitness = fitnessTest(resultss[0], N, T)
        iteration_file.write(f"Iteration {i}: Best Fitness = {current_fitness}\n")

        if current_fitness == 0 or i &gt;= max_iterations:
            break

        resultss = GeneAlgo(resultss, N, T)
        i += 1

if i == max_iterations:
    with open("output_final_result.txt", "w") as final_result_file:
        final_result_file.write("Result: Not optimal solution found\n")
else:
    with open("output_final_result.txt", "w") as final_result_file:
        final_result_file.write(f"Optimal Solution: {resultss[0]}\n")
        final_result_file.write(f"Fitness: {fitnessTest(resultss[0], N, T)}\n")
        final_result_file.write(f"Iterations: {i}\n")

#part2
import random

def TPoint_crossover(p1, p2, N, T):
    length = N * T
    i = random.randint(1, length - 2)
    j = random.randint(i + 1, length - 1)
    c1 = p1[:i] + p2[i:j] + p1[j:]
</font><a name="1"></a><font color="#00FF00"><a href="match11-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

    c2 = p2[:i] + p1[i:j] + p2[j:]
    return c1, c2

population = creating_population(N, T)
selected_parents = parent_choose(population)
p1 = population[selected_parents[0]]
p2 = population[selected_parents[1]]

with open("output_parents.txt", "w") as parents_file:
    parents_file.write(f"Parent 1: {p1}\n")
    parents_file.write(f"Parent 2: {p2}\n")

c1, c2 = TPoint_crossover(p1, p2, N, T)

with open("output_offspring.txt", "w") as offspring_file:
    offspring_file.write(f"Child 1: {c1}\n")
    offspring_file.write(f"Child 2: {c2}\n")</font></pre>
</body>
</html>
