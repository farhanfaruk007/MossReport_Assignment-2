<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/21301619_inzamul_kabir_tanvir_cse422_03_lab_assignment02_fall2024_-_INZAMUL_KABIR_TANVIR.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/13/24141099_mst_noushin_fariha_ronok_13__lab_assignment02_fall2024_mst_noushin_fariha_ronok.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141099_Mst Noushin Fariha Ronok_13__Lab_Assignment02_Fall2024 - MST NOUSHIN FARIHA RONOK

Automatically generated by Colab.

<a name="1"></a><font color="#00FF00"><a href="match65-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/1nu5b8b3S7v5Rw_PuAjlQHVmvZyU4E6ZE
"""

#task-1

import random
import math

file_doc_inpu= open("/content/422_lab2_inpu.txt")

result_file = open("result_1.txt", "w")

input_lines = file_doc_inpu.readlines()

inpu_seperate = input_lines[0].strip().split(' ')
time_seperate = int(inpu_seperate[0])

class_seperate = int(inpu_seperate[1])

total_member = {}
if  class_seperate &lt;= time_seperate :
    for s in range(0, 150):
        pairs = ''
        for t in range(0, time_seperate * class_seperate):

            pairs += str(random.randint(0, 1))
        total_member[pairs] = 0


def repeat_fault(R_TEMP):
    SET_for = 0
    for n in range(0, int(len(R_TEMP) / time_seperate)):
        repeat_timer = 0
        for j in range(n, len(R_TEMP), 3):

            if R_TEMP[j] == '1':

                repeat_timer += 1
        if repeat_timer &gt; 0:
            SET_for += (repeat_timer - 1)
    return SET_for


def penalty_how_to_calcu(sequence):
    penalty_score = 0

    for i in range(0, len(sequence), 3):
</font>        set_flag_consist = 0
        for j in range(i, i + 3):

<a name="2"></a><font color="#0000FF"><a href="match65-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

            if sequence[j] == '1':
                set_flag_consist += 1
        if set_flag_consist &gt; 0:

            penalty_score += (set_flag_consist - 1)
    return penalty_score


fit_value_joto = []


def given_algo_fitness(jum):
    fitness_down = -(repeat_fault(jum) + penalty_how_to_calcu(jum))
    fit_value_joto.append((jum, fitness_down))
    return fitness_down


def crossing_mechanism(set1, set2):
    mid = int(len(set1) / 2)
</font>    baby_offspring1 = set1[:mid] + set2[mid:]
    offsp2 = set1[mid:] + set2[:mid]
<a name="0"></a><font color="#FF0000"><a href="match65-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_28.gif"/></a>

    total_member[baby_offspring1] = 0
    total_member[offsp2] = 0
    return baby_offspring1, offsp2


def setp3_meutation(stor):
    seq_lst = list(stor)

    mut_pnt =  random.randint(0, len(seq_lst) - 1)

    seq_lst[mut_pnt] = str(1 - int(seq_lst[mut_pnt]))

    mutated_sequence = ''.join(seq_lst)

    return mutated_sequence


def main_algo_run_part(set_1, sett_2, times):

    daught1, daught2 = crossing_mechanism(set_1, sett_2)
    if given_algo_fitness(daught1) == 0:
        return daught1
    elif given_algo_fitness(daught2) == 0:
        return daught2
    else:

        times -= 1
        if times == 0:

            return "000000000"
        daught1 = setp3_meutation(daught1)
        daught2 = setp3_meutation(daught2)

        return main_algo_run_part(daught1, daught2, times)


inpu_1 = list(total_member.keys())[random.randint(0, len(total_member) - 1)]

inpu_2 = list(total_member.keys())[random.randint(0, len(total_member) - 1)]
final_rslt = main_algo_run_part(inpu_1, inpu_2, 1000)

if final_rslt in ["000000000", "111111111"]:

    print(' -100',  file =result_file)
else:
    print(final_rslt, file=result_file)

    for seq,  fit in fit_value_joto:

        if seq == final_rslt:
            print(fit, file= result_file)


file_doc_inpu.close()
</font>

result_file.close()

# task-2

import random


def ran_2_crossover (set1, set2):
    lene= len(set1)

    first_split = random.randint(1, lene - 2)

    second_split= random.randint(first_split + 1, lene - 1)

    child1 = set1[:first_split] + set2[first_split:second_split] + set1[second_split:]
    child2 = set2[:first_split] + set1[first_split:second_split] + set2[second_split:]

    return child1, child2


# Initialize the  total populate

total_number = {}
time_seperate = 9
cls_seperate = 1
for f in range(150):

    sequens = ''.join(str (random.randint(0, 1)) for _  in range(time_seperate  * cls_seperate))
    total_number[sequens] = 0

# Randomly select two parents from the population
parent1 = random.choice(list(total_number.keys()))
parent2 = random.choice(list(total_number.keys()))

# Perform two-point crossover
(chil1, chil2) = ran_2_crossover(parent1, parent2)

# Print the resultant offspring
print("Parent 1:", parent1)
print("Parent 2:", parent2)
print("Offspring 1:", chil1)
print("Offspring 2:", chil2)</pre>
</body>
</html>
