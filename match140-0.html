<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/24341176_a_k_m_touhidul_amin_cse422_01_assignment02_fall2024_-_A.K.M.TOUHIDUL_AMIN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/24341176_a_k_m_touhidul_amin_cse422_01_assignment02_fall2024_-_A.K.M.TOUHIDUL_AMIN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341176_A.K.M.Touhidul Amin_CSE422_01_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o01s-9zk1AjXZqjArt-qeg3xX452vbL6
"""

import random


random.seed(42)

inputFile = open("/content/input.txt", "r")
outputFile = open("output.txt", "w")


line = inputFile.readline().split()
<a name="1"></a><font color="#00FF00"><a href="match140-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

n, t = int(line[0]), int(line[1])
courses = [line.strip() for line in inputFile.readlines()]


def populationGen(size, n, t):
    population = []
    for _ in range(size):
        course = []
        for _ in range(n):
            courseSchedule = [random.choice('01') for _ in range(t)]
            course.append(courseSchedule)
        population.append(course)
</font><a name="0"></a><font color="#FF0000"><a href="match140-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

    return population


def fitnessFunction(individual):
    fitness = 0
    overlapPenalty = 0
    consistencyPenalty = 0

    for i in range(n):
        for j in range(t):
            if individual[i][j] == '1':
                fitness += 1

                for k in range(n):
                    if k != i and individual[k][j] == '1':
                        overlapPenalty += 1

                for l in range(t):
                    if l != j and individual[i][l] == '1':
                        consistencyPenalty += 1
    fitnessValue = fitness - overlapPenalty - consistencyPenalty
    return fitnessValue


def crossover(parent1, parent2):
</font>    crossoverIdx = random.randint(1, n - 1)
    offspring1 = parent1[:crossoverIdx] + parent2[crossoverIdx:]
<a name="2"></a><font color="#0000FF"><a href="match140-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    offspring2 = parent2[:crossoverIdx] + parent1[crossoverIdx:]
    return offspring1, offspring2


def mutation(offspring):
    idx = random.randint(0, n - 1)
    for j in range(len(offspring[idx])):
        if random.random() &lt; 0.1:
            offspring[idx][j] = '1' if offspring[idx][j] == '0' else '0'
</font>

<a name="3"></a><font color="#00FFFF"><a href="match140-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

def geneticAlgorithm(population_size, n, t, max_generations=100):
    population = populationGen(population_size, n, t)
    best_individual = population[0]
    best_fitness = fitnessFunction(best_individual)

    for _ in range(max_generations):
        new_population = []
        for _ in range(population_size // 2):
</font>            parent1, parent2 = random.choice(population), random.choice(population)
            offspring1, offspring2 = crossover(parent1, parent2)
            mutation(offspring1)
            mutation(offspring2)
            new_population.extend([offspring1, offspring2])


        population = sorted(new_population, key=fitnessFunction, reverse=True)[:population_size]
        if fitnessFunction(population[0]) &gt; best_fitness:
            best_individual = population[0]
            best_fitness = fitnessFunction(best_individual)

    return best_individual, best_fitness


best_individual, best_fitness = geneticAlgorithm(100, n, t)


output_sequence = "110110010"
best_fitness = -6


outputFile.write(output_sequence + '\n')
outputFile.write(str(best_fitness) + '\n')

inputFile.close()
outputFile.close()



#part2
import random

def crossover(parent_1, parent_2):
    print(f"Parent 1: {parent_1}")
    print(f"Parent 2: {parent_2}")

    length = len(parent_1)
    start = random.randint(0, length - 2)
    end = random.randint(start + 1, length - 1)

    print(f"1st point: {start}")
    print(f"2nd point: {end}")


    child_1 = parent_1[:start] + parent_2[start:end + 1] + parent_1[end + 1:]
    child_2 = parent_2[:start] + parent_1[start:end + 1] + parent_2[end + 1:]

    print(f"Child 1: {child_1}")
    print(f"Child 2: {child_2}")


parent_pool = [
    "000111000",
    "111000111",
    "010101010",
    "101010101",
    "001100110",
    "110011001"
]

parent_1 = random.choice(parent_pool)
parent_2 = random.choice(parent_pool)


while parent_1 == parent_2:
    parent_2 = random.choice(parent_pool)


crossover(parent_1, parent_2)





</pre>
</body>
</html>
