<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/21101165_miftahul_jannat_orpi_cse422_06_assignment02_fall2024_-_MIFTAHUL_JANNAT_ORPI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/21101165_miftahul_jannat_orpi_cse422_06_assignment02_fall2024_-_MIFTAHUL_JANNAT_ORPI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101165_Miftahul Jannat Orpi_CSE422_06_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ya7ZkH_pX7b2OEB13tUWWB2LXUpgKP4P
"""

import random

def generate_schedule(num_courses, time_slots):  # Generating schedule
    schedule = [0] * (num_courses * time_slots)
    for course in range(num_courses):
        slot = random.randint(0, time_slots - 1)
        schedule[slot * num_courses + course] = 1
    return schedule

def evaluate_fitness(schedule, num_courses, time_slots):  # ekhane Calculate overlapping and consistency penalties
    overlap_penalty = 0
    consistency_penalty = 0

    for slot in range(time_slots):
        slot_courses = schedule[slot * num_courses:(slot + 1) * num_courses]
        course_count = sum(slot_courses)

        if course_count &gt; 1:
            overlap_penalty += (course_count - 1)


    for course in range(num_courses):
        course_schedule = [schedule[slot * num_courses + course] for slot in range(time_slots)]  #timeslots course ke findout er jonno
        scheduled_times = sum(course_schedule)

        if scheduled_times != 1:
            consistency_penalty += abs(scheduled_times - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty

def select_parent(population, fitness_scores):  # fitness based e selecting parents
    fitness_sum = sum(fitness_scores)
    probabilities = [score / fitness_sum for score in fitness_scores]
    return population[random.choices(range(len(population)), probabilities, k=1)[0]]

def perform_crossover(parent1, parent2):  # crossover for new offspring
    crossover_point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    return offspring1, offspring2

def apply_mutation(schedule, mutation_rate):  #given mutation rate e applying mutation
    for idx in range(len(schedule)):
        if random.random() &lt; mutation_rate:
            schedule[idx] = 1 - schedule[idx]
    return schedule

def genetic_algorithm(num_courses, time_slots, max_generations=5000, population_size=200, mutation_rate=0.01):
    population = [generate_schedule(num_courses, time_slots) for _ in range(population_size)]

    for generation in range(max_generations):
        fitness_scores = [evaluate_fitness(schedule, num_courses, time_slots) for schedule in population]
        if 0 in fitness_scores:
            break

        new_population = []
        for _ in range(population_size // 2):
            parent1 = select_parent(population, fitness_scores)
            parent2 = select_parent(population, fitness_scores)
            child1, child2 = perform_crossover(parent1, parent2)
            new_population.append(apply_mutation(child1, mutation_rate))
            new_population.append(apply_mutation(child2, mutation_rate))

        population = new_population

    best_schedule = max(population, key=lambda sched: evaluate_fitness(sched, num_courses, time_slots))
    return best_schedule, evaluate_fitness(best_schedule, num_courses, time_slots), population

<a name="1"></a><font color="#00FF00"><a href="match228-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

print("Enter total number of courses and time slots: ")
num_courses, time_slots = map(int, input().split())

print("\nEnter course codes:")
course_list = [input().strip() for _ in range(num_courses)]

best_schedule, best_fitness, final_population = genetic_algorithm(num_courses, time_slots)

#binary strings e converting
</font><a name="0"></a><font color="#FF0000"><a href="match228-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

final_population = ["".join(map(str, chrom)) for chrom in final_population]

print("\nBest Schedule Binary String: {}".format("".join(map(str, best_schedule))))
print("Fitness Value of Best Schedule: {}".format(best_fitness))

# Task 2: Two-point Crossover
parent1, parent2 = random.sample(final_population, 2)

def two_point_crossover(parent1, parent2):
    point1 = random.randint(0, len(parent1) - 2)
    point2 = random.randint(point1 + 1, len(parent1) - 1)
</font>
    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
<a name="2"></a><font color="#0000FF"><a href="match228-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]
    return offspring1, offspring2

offspring1, offspring2 = two_point_crossover(parent1, parent2)

print("\nParents and Offspring from Two-Point Crossover:")
print(f"Parent 1: {parent1}")
print(f"Parent 2: {parent2}")
print(f"Offspring 1: {offspring1}")
</font>print(f"Offspring 2: {offspring2}")

</pre>
</body>
</html>
