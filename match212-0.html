<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/11/21301645_MugdhaSaha_CSE422_11_Lab_Assignment2_Fall2024_-_Mugdha_Saha.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/11/21301645_MugdhaSaha_CSE422_11_Lab_Assignment2_Fall2024_-_Mugdha_Saha.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fEajjSJUbgGlcMNmkp3Fj4RZkAj-fTWe
"""

import random

def chrom_making(n, t):
  return ''.join(random.choice('01') for i in range(n * t))

def fun_fict(chrom, n, t):
  reduce_pen  = 0
  contasnt_pen = 0
  time_slot = []
  for i in range(t):
    time_slot.append(chrom[i * n:(i + 1) * n])
<a name="2"></a><font color="#0000FF"><a href="match212-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

  for i in time_slot:
    course_value = sum(int(course) for course in i)

    if course_value &gt; 1:
      reduce_pen  += (course_value - 1)

  for course_index in range(n):

    course_scheduled_count = sum(int(timeslot[course_index]) for timeslot in time_slot)
</font>
    if course_scheduled_count != 1:
      contasnt_pen += abs(course_scheduled_count - 1)

  total_value_of_penalty = reduce_pen  + contasnt_pen

  return -total_value_of_penalty

def choose_parents(p_checking, fit_check_scores):
  total_fitness = sum(fit_check_scores)
  prob_select_part = [fit_check / total_fitness for fit_check in fit_check_scores]
  parents = random.choices(p_checking, weights=prob_select_part, k=2)
  return parents

def run_crossover(p1, p2, n, t):
  cross_value = random.randint(1, len(p1) - 1)
  value1= p1[:cross_value]
  value2= p2[cross_value:]
  c1 = value1 + value2
  c2 = value2 + value1
  return c1, c2

<a name="0"></a><font color="#FF0000"><a href="match212-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

def run_mutate(chrom, mutationRate):
  string_1 = ''
  for j in chrom:
    if random.random() &lt; mutationRate:
      string_1 += '1' if j == '0' else '0'
    else:
      string_1 += j
  return string_1

def run_genetic_algorithm(n_course, t_timing , pop_part, iteration_max, rate_of_mutation):
  number_of_population = [chrom_making(n_course, t_timing ) for k in range(pop_part)]
  for i in range(iteration_max):
    fitness_scores = [fun_fict(chrom, n_course, t_timing ) for chrom in number_of_population]
</font>    if max(fitness_scores) == 0:
      break

    next_generation = []
    while len(next_generation) &lt; pop_part:
      parent1, parent2 = choose_parents(number_of_population, fitness_scores)

      c1, c2 = run_crossover(parent1, parent2, n_course, t_timing )
<a name="1"></a><font color="#00FF00"><a href="match212-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

      c1 = run_mutate(c1, rate_of_mutation)
      c2 = run_mutate(c2, rate_of_mutation)

      next_generation.extend([c1, c2])

    number_of_population = next_generation
  finding_best_chromo = max(number_of_population, key=lambda chrom: fun_fict(chrom, n_course, t_timing ))
  return finding_best_chromo, fun_fict(finding_best_chromo, n_course, t_timing )

n, t = map(int, input("Enter the number of list_of_course and t_timing  (N T): ").split())
</font>list_of_course = [input(f"Enter course code for course {y + 1}: ") for y in range(n)]

best_chrom, fit_check_value = run_genetic_algorithm(n, t, 100, 100, 0.01)

print("chorm: ",  best_chrom)
print( "Fitness: ", fit_check_value)

def generate_offspring(parent1, parent2):
    if len(parent1) != len(parent2):
        raise ValueError("Both parents must have the same length.")

    import random
    crossover1 = random.randint(0, len(parent1) - 2)
    crossover2 = random.randint(crossover1 + 1, len(parent1) - 1)

    child1 = parent1[:crossover1] + parent2[crossover1:crossover2 + 1] + parent1[crossover2 + 1:]
    child2 = parent2[:crossover1] + parent1[crossover1:crossover2 + 1] + parent2[crossover2 + 1:]

    return child1, child2

parent1 = "000111000"
parent2 = "111000111"

print("Parent 1:", parent1)
print("Parent 2:", parent2)

offspring1, offspring2 = generate_offspring(parent1, parent2)
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)</pre>
</body>
</html>
