<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/5/20301393_lab2_sec5_fahim_ahamed_romit.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/5/20301393_lab2_sec5_fahim_ahamed_romit.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20301393_Lab2_Sec5 - FAHIM AHAMED ROMIT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwMt3vTq2sls_GGqZxaAomZl1mYvviFD
"""

import random

def initialize_population(population_size, chromosome_length):

    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(population_size)]

def evaluate_fitness(chromosome, num_courses, num_timeslots):

    overlap_penalty = 0
    consistency_penalty = 0

    # Calculate overlap penalty
    for timeslot in range(num_timeslots):
        timeslot_courses = chromosome[timeslot * num_courses:(timeslot + 1) * num_courses]
        if sum(timeslot_courses) &gt; 1:
            overlap_penalty += sum(timeslot_courses) - 1

    # Calculate consistency penalty
    course_counts = [0] * num_courses
    for timeslot in range(num_timeslots):
        timeslot_courses = chromosome[timeslot * num_courses:(timeslot + 1) * num_courses]
        for course in range(num_courses):
            course_counts[course] += timeslot_courses[course]

    for count in course_counts:
        consistency_penalty += abs(count - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty  # Negative fitness for maximization

def select_parents(population, fitnesses):

    total_fitness = sum(fitnesses)
    parent1 = select_parent(population, fitnesses, total_fitness)
    parent2 = select_parent(population, fitnesses, total_fitness)
    return parent1, parent2

def select_parent(population, fitnesses, total_fitness):
    """Selects a single parent using fitness-proportional selection."""
    pick = random.uniform(0, total_fitness)
    current_fitness = 0
    for i, fitness in enumerate(fitnesses):
        current_fitness += fitness
        if current_fitness &gt; pick:
            return population[i]
    return population[0]  # Fallback if an error occurs

def crossover_single_point(parent1, parent2):

    crossover_point = random.randint(1, len(parent1) - 2)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

def mutate(chromosome, mutation_rate):

    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
<a name="1"></a><font color="#00FF00"><a href="match190-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

            chromosome[i] = 1 - chromosome[i]

def genetic_algorithm(num_courses, num_timeslots, population_size, mutation_rate, max_iterations):

    chromosome_length = num_courses * num_timeslots
    population = initialize_population(population_size, chromosome_length)
    best_chromosome = None
    best_fitness = float('-inf')

    for _ in range(max_iterations):
        fitnesses = [evaluate_fitness(chromosome, num_courses, num_timeslots) for chromosome in population]
</font>        for i, fitness in enumerate(fitnesses):
<a name="3"></a><font color="#00FFFF"><a href="match190-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

            if fitness &gt; best_fitness:
                best_fitness = fitness
                best_chromosome = population[i]

        new_population = []
        while len(new_population) &lt; population_size:
            parent1, parent2 = select_parents(population, fitnesses)
            child1, child2 = crossover_single_point(parent1, parent2)
</font>            mutate(child1, mutation_rate)
            mutate(child2, mutation_rate)
            new_population.extend([child1, child2])

        population = new_population[:population_size]

    return best_chromosome, best_fitness

def read_input_file(file_name):

    with open(file_name, 'r') as file:
        lines = file.readlines()
<a name="2"></a><font color="#0000FF"><a href="match190-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        num_courses, num_timeslots = map(int, lines[0].strip().split())
        courses = [line.strip() for line in lines[1:num_courses + 1]]
    return num_courses, num_timeslots, courses

def main():
</font>
    input_file = 'input.txt'
    num_courses, num_timeslots, courses = read_input_file(input_file)

    population_size = 10
    mutation_rate = 0.01
    max_iterations = 100

    best_chromosome, best_fitness = genetic_algorithm(num_courses, num_timeslots, population_size, mutation_rate, max_iterations)

    print("Best Chromosome:", ''.join(map(str, best_chromosome)))
    print("Best Fitness:", best_fitness)

if __name__ == "__main__":
    main()

import random

def exchange_genetic_material(genome_a, genome_b, start_index, end_index):


    new_genome_a = genome_a[:start_index] + genome_b[start_index:end_index] + genome_a[end_index:]
    new_genome_b = genome_b[:start_index] + genome_a[start_index:end_index] + genome_b[end_index:]
    return new_genome_a, new_genome_b

def two_point_crossover_operator(parent_a, parent_b):

    genome_length = len(parent_a)
    first_crossover_point = random.randint(0, genome_length - 2)
    second_crossover_point = random.randint(first_crossover_point + 1, genome_length - 1)

    return exchange_genetic_material(parent_a, parent_b, first_crossover_point, second_crossover_point)

# Example usage
original_genome_1 = [0, 0, 0, 1, 1, 1, 0, 0, 0]
original_genome_2 = [1, 1, 1, 0, 0, 0, 1, 1, 1]

new_genome_1, new_genome_2 = two_point_crossover_operator(original_genome_1, original_genome_2)

print("Original Genome 1:", ''.join(map(str, original_genome_1)))
print("Original Genome 2:", ''.join(map(str, original_genome_2)))
print("New Genome 1:    ", ''.join(map(str, new_genome_1)))
print("New Genome 2:    ", ''.join(map(str, new_genome_2)))

import random

def initialize_population(population_size, chromosome_length):

    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(population_size)]

<a name="0"></a><font color="#FF0000"><a href="match190-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

def select_best_from_tournament(population, fitnesses, tournament_size=3):

    tournament_participants = random.sample(list(zip(population, fitnesses)), tournament_size)
    tournament_participants.sort(key=lambda x: x[1], reverse=True)
    return tournament_participants[0][0]  # Return the fittest individual

def genetic_algorithm_tournament_selection(num_courses, num_timeslots, population_size, mutation_rate, max_generations, tournament_size):
</font>
    chromosome_length = num_courses * num_timeslots
    population = initialize_population(population_size, chromosome_length)
    best_solution = None
    best_fitness = float('-inf')

    for generation in range(max_generations):
        fitnesses = [evaluate_fitness(chromosome, num_courses, num_timeslots) for chromosome in population]

        for i, fitness in enumerate(fitnesses):
            if fitness &gt; best_fitness:
                best_fitness = fitness
                best_solution = population[i]

        new_population = []
        while len(new_population) &lt; population_size:
            parent_a = select_best_from_tournament(population, fitnesses, tournament_size)
            parent_b = select_best_from_tournament(population, fitnesses, tournament_size)
            offspring_a, offspring_b = crossover(parent_a, parent_b)  # Assuming crossover function exists
            mutate(offspring_a, mutation_rate)  # Assuming mutation function exists
            mutate(offspring_b, mutation_rate)  # Assuming mutation function exists
            new_population.extend([offspring_a, offspring_b])

        population = new_population

    return best_solution, best_fitness</pre>
</body>
</html>
