<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/21201453_aniruddha_ayan_cse422_01_assignment02_fall2024_-_ANIRUDDHA_AYAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/21201453_aniruddha_ayan_cse422_01_assignment02_fall2024_-_ANIRUDDHA_AYAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201453_Aniruddha Ayan_CSE422_01_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d9kOk52ILD98O6JmWk99DEJXjQTDEUgR
"""

# part 1
import random

#  handling input first
def get_input():
    N, T = map(int, input().split())  # Number of courses and timeslots
    courses = [input().strip() for _ in range(N)]  # Course codes
    return N, T, courses

# then we generate Chromosome
def generate_random_chromosome(N, T):
    return ''.join(random.choice('01') for _ in range(N * T))

# workin on fitness Function
def calculate_fitness(chromosome, N, T):
# Splitting chromosome into timeslots
<a name="2"></a><font color="#0000FF"><a href="match237-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    timeslots = [chromosome[i * N:(i + 1) * N] for i in range(T)]

# Overlap penalty
    overlap_penalty = 0
    for slot in timeslots:
</font>        scheduled_courses = slot.count('1')
        if scheduled_courses &gt; 1:
            overlap_penalty += scheduled_courses - 1

# Consistency penalty
    course_schedule_count = [0] * N
    for slot in timeslots:
        for i, bit in enumerate(slot):
            if bit == '1':
                course_schedule_count[i] += 1
    consistency_penalty = sum(abs(count - 1) for count in course_schedule_count)

# Total penalty and fitness
    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty

# Parent Selection
def select_parents(population, fitnesses):
    return random.choices(population, weights=fitnesses, k=2)

# Single-Point Crossover
def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)  # Random crossover point
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2

# Mutation
def mutate(chromosome, mutation_rate=0.1):
    chromosome = list(chromosome)
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
            chromosome[i] = '1' if chromosome[i] == '0' else '0'
    return ''.join(chromosome)

# Genetic Algorithm
def genetic_algorithm(N, T, population_size=50, max_generations=100):
# Initial population
<a name="0"></a><font color="#FF0000"><a href="match237-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

    population = [generate_random_chromosome(N, T) for _ in range(population_size)]

    for generation in range(max_generations):
# Evaluate fitness for the population
        fitnesses = [calculate_fitness(chromosome, N, T) for chromosome in population]

# Check for optimal solution
        max_fitness = max(fitnesses)
        if max_fitness == 0:
            best_chromosome = population[fitnesses.index(max_fitness)]
            return best_chromosome, max_fitness

# Create next generation
        new_population = []
        while len(new_population) &lt; population_size:
# Select parents
            parent1, parent2 = select_parents(population, fitnesses)
# Performing crossover
            offspring1, offspring2 = crossover(parent1, parent2)
# Performing mutation
            offspring1 = mutate(offspring1)
</font>            offspring2 = mutate(offspring2)
# Adding offspring to new population
            new_population.extend([offspring1, offspring2])

# Update population
        population = new_population

# Return best chromosome and its fitness
    fitnesses = [calculate_fitness(chromosome, N, T) for chromosome in population]
    best_chromosome = population[fitnesses.index(max(fitnesses))]
    return best_chromosome, max(fitnesses)

# Main execution
if __name__ == "__main__":
# Read input
    N, T, courses = get_input()

# Run genetic algorithm
    best_schedule, best_fitness = genetic_algorithm(N, T)

# Print output
    print(best_schedule)
    print(best_fitness)

# part 2
import random

# Function performing a 2point crossover
def two_point_crossover(parent1, parent2):
    # Ensure parents are of the same length
    if len(parent1) != len(parent2):
        raise ValueError("Both parents must have the same length!")

    # Get the length of the chromosome
    length = len(parent1)

    # Randomly choose two points for crossover
    point1 = random.randint(1, length - 2)  # First point (avoiding ends)
    point2 = random.randint(point1 + 1, length - 1)  # Second point (after point1)

    # Perform crossover to create offspring
    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
<a name="1"></a><font color="#00FF00"><a href="match237-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2, point1, point2

# Main execution
if __name__ == "__main__":
</font>    # Example parents
    parent1 = "000111000"
    parent2 = "111000111"

    # Perform two-point crossover
    offspring1, offspring2, point1, point2 = two_point_crossover(parent1, parent2)

    # Print the results
    print(f"Parent 1:  {parent1}")
    print(f"Parent 2:  {parent2}")
    print(f"1st Point: Between index {point1} and {point1 + 1}")
    print(f"2nd Point: Between index {point2} and {point2 + 1}")
    print(f"Offspring 1: {offspring1}")
    print(f"Offspring 2: {offspring2}")</pre>
</body>
</html>
