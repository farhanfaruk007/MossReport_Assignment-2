<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/24141100_anwesha_roy_cse422_04_assignment02_fall2024_-_ANWESHA_ROY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/24141100_anwesha_roy_cse422_04_assignment02_fall2024_-_ANWESHA_ROY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141100_Anwesha Roy_CSE422_04_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16DtDoNUpLQmx0gFAig1Yf7mvBUFtV-M3
"""

import random
int_f = open("/content/inputfile.txt","r")
<a name="5"></a><font color="#FF0000"><a href="match110-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

read = int_f.readline().split()
A, B = int(read[0]), int(read[1])
store = []
count = 0

while count &lt; A:
</font>    store.append(int_f.readline().strip())
    count += 1

def group(print_size, A, B):
    store_p = []

    for i in range(print_size):
        store_chr = []
        for j in range(A * B):
            store_chr.append(random.randint(0, 1))

        store_p.append(store_chr)
    return store_p


def check_fit_ness(store_chr, A, B):
    ovrlp = 0
    con_prnt = 0
    crs = [0] * A
<a name="3"></a><font color="#00FFFF"><a href="match110-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    cnt_ts = [0] * B

    for x in range(B):
        num = store_chr[x * A:(x + 1) * A]
        cross_point = num.count(1)
        if cross_point &gt; 1:
            ovrlp += (cross_point - 1)
</font>        cnt_ts[x] = cross_point

<a name="4"></a><font color="#FF00FF"><a href="match110-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    for s in range(A):
        crs[s] = sum(store_chr[j * A + s] for j in range(B))

    for counter in crs:
        if counter != 1:
</font>            con_prnt += abs(counter - 1)

    check_fit_ness = -(ovrlp + con_prnt)
    return check_fit_ness

def selection_step(value, store_fitn):
    total_store_fitn = sum(store_fitn)
    weak_slt = list(map(lambda f: f / total_store_fitn, store_fitn))
    store_pint = random.choices(value, weights=weak_slt, k=2)
    return store_pint

def s_point_cross_over(point_1, point_2, A, B):
    points = random.sample(range(1, A * B), 2)
    cr_points = sorted(points)
    off_spring_1 = point_1[:cr_points[0]] + point_2[cr_points[0]:cr_points[1]] + point_1[cr_points[1]:]
<a name="2"></a><font color="#0000FF"><a href="match110-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    off_spring_2 = point_2[:cr_points[0]] + point_1[cr_points[0]:cr_points[1]] + point_2[cr_points[1]:]
    return off_spring_1, off_spring_2


def mutation_step(store_chr, rate = 0.01):
</font>    for x in range(len(store_chr)):
        if random.random() &lt; rate:
            store_chr[x] = 1 - store_chr[x]
    return store_chr


def tpoint_cross_over(point_1, point_2, A, B):
    cr_point1, cr_point2 = tuple(sorted(random.sample(range(1, A * B - 1), 2)))
    off_spring_1 = point_1[:cr_point1] + point_2[cr_point1:cr_point2] + point_1[cr_point2:]
<a name="6"></a><font color="#00FF00"><a href="match110-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    off_spring_2 = point_2[:cr_point1] + point_1[cr_point1:cr_point2] + point_2[cr_point2:]
    return off_spring_1, off_spring_2


def g_algo(A, B,_ , print_size = 10, total_iter = 100):
    p = group(print_size, A, B)
    betterones = None
    fittests = float('-inf')
</font>
<a name="0"></a><font color="#FF0000"><a href="match110-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

    for genetics in range(total_iter):
        store_fitn = [check_fit_ness(store_chr, A, B) for store_chr in p]
        for a in range(print_size):
            if store_fitn[a] &gt; fittests:
                fittests = store_fitn[a]
                betterones = p[a]
        new_pnt = []
        while len(new_pnt) &lt; print_size:
            point_1, point_2 = selection_step(p, store_fitn)
            off_spring_1, off_spring_2 = s_point_cross_over(point_1, point_2, A, B)
            new_pnt.append(mutation_step(off_spring_1))
            new_pnt.append(mutation_step(off_spring_2))
        p = new_pnt[:print_size]
</font>    return betterones, fittests
<a name="1"></a><font color="#00FF00"><a href="match110-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

betterones, fittests = g_algo(A, B, store)
char_str = ''.join(map(str, betterones))

print(char_str)

print(fittests)

print_size = 5

value = group(print_size, A, B)

store_fitn = [check_fit_ness(store_chr, A, B) for store_chr in value]
point_1, point_2 = selection_step(value, store_fitn)
off_spring_1, off_spring_2 = tpoint_cross_over(point_1, point_2, A, B)

flags = ["Parent 1", "Parent 2","Offspring 1","Offspring 2"]

n = [point_1, point_2, off_spring_1, off_spring_2]
</font>
for x in range(len(flags)):
    ind_str = ''.join(str(gene) for gene in n[x])
    print(f"{flags [x]}: {ind_str}")</pre>
</body>
</html>
