<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/24341265_tohura_shehreen_cse422_01_assignment02_fall2024_-_TOHURA_SHEHREEN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/24341265_tohura_shehreen_cse422_01_assignment02_fall2024_-_TOHURA_SHEHREEN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341265_Tohura Shehreen_CSE422_01_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R8KaDi9DRALt6_rb3S9MBpawbJskEcrU
"""

import random

class GeneticAlgorithmScheduler:
    def __init__(self, num_courses, num_timeslots):
        if num_courses &lt;= 0 or num_timeslots &lt;= 0:
            raise ValueError("Number of courses and timeslots must be positive integers.")
        if num_timeslots &lt; num_courses:
            raise ValueError("Number of timeslots must be greater than or equal to the number of courses.")

        self.num_courses = num_courses
        self.num_timeslots = num_timeslots

    def chromosome(self):
        length = self.num_courses * self.num_timeslots
        while True:
            chrom = [random.randint(0, 1) for _ in range(length)]
            chrom_string = ''.join(map(str, chrom))
            if chrom_string.count('1') &gt; 0:
                return chrom_string

    def generate_population(self, population_size_range=(10, 20)):
        population_size = random.randint(population_size_range[0], population_size_range[1])
        return [self.chromosome() for _ in range(population_size)]

    def fitness(self, chrom):
        n, t = self.num_courses, self.num_timeslots
<a name="0"></a><font color="#FF0000"><a href="match232-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

        parts = [chrom[i:i + n] for i in range(0, len(chrom), n)]
        overlap_penalty = 0
        course_schedule = [0] * n

        for part in parts:
            count = part.count('1')
            if count &gt; 1:
                overlap_penalty += count - 1
            for i, c in enumerate(part):
                if c == '1':
                    course_schedule[i] += 1

        consistency_penalty = sum(abs(scheduled - 1) for scheduled in course_schedule)

        return -(overlap_penalty + consistency_penalty)

    def tournament_selection(self, population, min_tournament_size=2, max_tournament_size=None):
</font>        if max_tournament_size is None:
            max_tournament_size = len(population)

        tournament_size = random.randint(min_tournament_size, max_tournament_size)
        tournament_indices = random.sample(range(len(population)), tournament_size)
        tournament_fitness = [self.fitness(population[idx]) for idx in tournament_indices]

        best_index = min(range(tournament_size), key=lambda i: tournament_fitness[i])
        return population[tournament_indices[best_index]]

    def select_parents(self, population, min_tournament_size=2, max_tournament_size=None):
        parent1 = self.tournament_selection(population, min_tournament_size, max_tournament_size)
        parent2 = self.tournament_selection(population, min_tournament_size, max_tournament_size)

        while parent1 == parent2:
            parent2 = self.tournament_selection(population, min_tournament_size, max_tournament_size)

        return parent1, parent2

<a name="1"></a><font color="#00FF00"><a href="match232-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

    @staticmethod
    def single_point_crossover(parent1, parent2):
        if len(parent1) != len(parent2):
            raise ValueError("Parents must have the same length")

        crossover_point = random.randint(1, len(parent1) - 1)
        offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
</font>        offspring2 = parent2[:crossover_point] + parent1[crossover_point:]

        return offspring1, offspring2

    @staticmethod
    def mutate(chromosome, mutation_rate_range=(0.01, 0.1)):
        mutation_rate = random.uniform(*mutation_rate_range)
        mutated_chromosome = ""

        for gene in chromosome:
            if random.random() &lt; mutation_rate:
                mutated_chromosome += '1' if gene == '0' else '0'
            else:
                mutated_chromosome += gene

        return mutated_chromosome

def entry():
    num_courses = int(input("Number of Courses: "))
    num_timeslots = int(input("Number of Time Slots: "))

    course_list = [input(f"Input Course-{k + 1} Name: ") for k in range(num_courses)]

    scheduler = GeneticAlgorithmScheduler(num_courses, num_timeslots)
    population = scheduler.generate_population()
    print(f"Generated Population: {population}")


    parent1, parent2 = scheduler.select_parents(population)
    print(f"Selected Parents:\nParent 1: {parent1}\nParent 2: {parent2}")

    offspring1, offspring2 = scheduler.single_point_crossover(parent1, parent2)
    print(f"Offspring:\nOffspring 1: {offspring1}\nOffspring 2: {offspring2}")


    mutated_offspring = scheduler.mutate(offspring1)
    print(f"Mutated Offspring: {mutated_offspring}")


    final_chromosome = mutated_offspring
    print(f"Final Chromosome: {final_chromosome}")

entry()</pre>
</body>
</html>
