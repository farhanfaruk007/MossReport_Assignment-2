<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/22101229_Aparup_Chowdhury_CSE422_04_Assignment02_Fall2024_-_APARUP_CHOWDHURY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/24341058_arjun_cse422_lab12_ass02_-_ARJUN_SAHA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341058_Arjun_CSE422_Lab12_Ass02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-RmtCFqKUvyHpxwaoeP9fGGlwL4pIHEg
"""

<a name="0"></a><font color="#FF0000"><a href="match83-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_45.gif"/></a>

import math
import random
def overlap_penalty(time_slots,N,T):
    cheack_arr=[]
    overlap_P=0
    for i in range(T):
        indivisual_slot=time_slots[i*N:(i+1)*N]
        # print(indivisual_slot)
        count=max(indivisual_slot.count("1")-1,0)
        overlap_P+=count
    return overlap_P
def consistency_panelty(time_slots,N,T):
    panelty=0

    for i in range(N):
        panelty_count = 0
        for j in range(T):
            panelty_count+=int(time_slots[j*N+i])
            # print(panelty_count)
            # panelty-=1

        panelty+=abs(panelty_count-1)
        # print(panelty)
    return panelty

def calculate_fitness(time_slots,N,T):
    panelty= -(overlap_penalty(time_slots,N,T)+consistency_panelty(time_slots,N,T))
    return panelty
def create_population(n,t,population_size):
    population_list=[]

    for j in range(population_size):
        population = ""
        for i in range(n*t):
            population+=random.choice('01')
        # print(population)
        population_list.append(population)
    return population_list
def parents_selection(population):
    return random.choice(population),random.choice(population)
def crossover(parent1,parent2,N,T):
    point=random.randint(0,N*T-1)
    child1=parent1[0:point]+parent2[point:]
    child2=parent2[0:point]+parent1[point:]
    return child1,child2
def mutation(child,N,T):
    point=random.randint(1,N*T-1)
    list1=list(child)
    # print(list1)
    if list1[point]=="1":
        list1[point]="0"
    else:
        list1[point]="1"
    return "".join(list1)

def genetic_algo(N,T,population_size,iterations):
    population=create_population(N,T,population_size)
    # print(population)
    lowest_fitness=-math.inf
    best_slot=None
    for _ in range(iterations):
        new_population=[]
        for _ in range(population_size//2):
            parent1,parent2=parents_selection(population)
            child1,child2=crossover(parent1,parent2,N,T)
            new_population.extend([mutation(child1,N,T),mutation(child2,N,T)])
        population=new_population
        for slots in population:
            fitess_value=calculate_fitness(slots,N,T)

            if fitess_value&gt;lowest_fitness:
                lowest_fitness = fitess_value
                best_slot = slots

            if lowest_fitness==0:
                break
    return lowest_fitness,best_slot


N,T=int(input("Enter Num_of_Courses: ")),int(input("Enter TimeSlots:"))
</font>courses=[input("Enter courses: ") for i in range(N)]
if T&lt;N:
    print("TimeSlots can't be less than Num_of_Courses")
else:
    fitness,schedule=genetic_algo(N,T,population_size=100,iterations=1000)
    print(schedule)
    print(fitness)

"""Task 2

"""

import random

def overlap_penalty(time_slots, N, T):
    overlap_P = 0
    for i in range(T):
        indivisual_slot = time_slots[i*N:(i+1)*N]
        overlap_P += max(indivisual_slot.count("1")-1, 0)
    return overlap_P

def consistency_panelty(time_slots, N, T):
    panelty = 0
    for i in range(N):
        panelty_count = 0
        for j in range(T):
            panelty_count += int(time_slots[j*N+i])
        panelty += abs(panelty_count-1)
    return panelty

def calculate_fitness(time_slots, N, T):
    return -(overlap_penalty(time_slots, N, T) + consistency_panelty(time_slots, N, T))

def create_population(n, t, population_size):
    return [''.join(random.choice('01') for _ in range(n*t)) for _ in range(population_size)]

def crossover(parent1, parent2, N, T):
    point = random.randint(0, N*T-1)
    return parent1[:point]+parent2[point:], parent2[:point]+parent1[point:]

def mutation(child, N, T):
    point = random.randint(1, N*T-1)
    list1 = list(child)
    list1[point] = '0' if list1[point] == '1' else '1'
    return ''.join(list1)

def genetic_algo(N, T, population_size, iterations):
    population = create_population(N, T, population_size)
    lowest_fitness = float('-inf')
    best_slot = None

    for _ in range(iterations):
        new_population = []
        for _ in range(population_size//2):
            parent1, parent2 = random.choice(population), random.choice(population)
            child1, child2 = crossover(parent1, parent2, N, T)
            new_population.extend([mutation(child1, N, T), mutation(child2, N, T)])

        population = new_population
        for slots in population:
            fitness_value = calculate_fitness(slots, N, T)
            if fitness_value &gt; lowest_fitness:
                lowest_fitness = fitness_value
                best_slot = slots
            if lowest_fitness == 0:
                break

    return lowest_fitness, best_slot

with open('input.txt', 'r') as file:
    N, T = map(int, file.readline().strip().split(' '))
    courses = [file.readline().strip() for _ in range(N)]

if T &lt; N:
    print("TimeSlots can't be less than Num_of_Courses")
else:
    fitness, schedule = genetic_algo(N, T, population_size=100, iterations=1000)
    print(schedule)
    print(fitness)</pre>
</body>
</html>
