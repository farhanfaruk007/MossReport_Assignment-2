<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/22301781_zymazareenhaque_cse422_01_assignment02_fall2024_-_ZYMA_ZAREEN_HAQUE.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/1/22301781_zymazareenhaque_cse422_01_assignment02_fall2024_-_ZYMA_ZAREEN_HAQUE.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22301781_ZymaZareenHaque_CSE422_01_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yIIePEWwDu5XVl5FL3tsgZOxzWPujimY
"""

##TASK-1
import random


def calculate_fitness(chromosome, N, T):
    overlap_penalty = 0
    consistency_penalty = 0


    segments = [chromosome[i * N:(i + 1) * N] for i in range(T)]


    for s in segments:
        courses_in_timeslot = sum(s)
        if courses_in_timeslot &gt; 1:
            overlap_penalty += courses_in_timeslot - 1


    course_counts = [0] * N
    for s in segments:
        for i in range(N):
<a name="1"></a><font color="#00FF00"><a href="match245-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            course_counts[i] += s[i]

    for c in course_counts:
        consistency_penalty += abs(c - 1)


    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty


def single_point_crossover(parent1, parent2):
</font>    point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2



def mutate(chromosome, mutation_rate=0.01):
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
            chromosome[i] = 1 - chromosome[i]



def generate_population(pop_size, N, T):
    population = []
    for _ in range(pop_size):
        chromosome = [random.randint(0, 1) for _ in range(N * T)]
        while sum(chromosome) == 0:  #to ensure no all-zero chromosomes
            chromosome = [random.randint(0, 1) for _ in range(N * T)]
        population.append(chromosome)
<a name="2"></a><font color="#0000FF"><a href="match245-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    return population



def genetic_algorithm(N, T, courses, max_generations=100, pop_size=20, mutation_rate=0.01):
    population = generate_population(pop_size, N, T)
    best_fitness = float('-inf')
</font>    best_chromosome = None

    for generation in range(max_generations):

        fitness_scores = [calculate_fitness(chromosome, N, T) for chromosome in population]

        for i in range(len(population)):
            if fitness_scores[i] &gt; best_fitness:
                best_fitness = fitness_scores[i]
                best_chromosome = population[i]


        selected = random.choices(
            population, weights=[1 / (1 - f + 1e-6) for f in fitness_scores], k=pop_size // 2
        )


        next_generation = []
        for i in range(0, len(selected), 2):
            if i + 1 &lt; len(selected):
                offspring1, offspring2 = single_point_crossover(selected[i], selected[i + 1])
                next_generation.extend([offspring1, offspring2])


        for individual in next_generation:
            mutate(individual, mutation_rate)


        population = next_generation

        #optimality check
        if best_fitness == 0:
            break

    return best_chromosome, best_fitness

def two_point_crossover(parent1, parent2):
    length = len(parent1)


    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)


    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
<a name="0"></a><font color="#FF0000"><a href="match245-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2

N, T = map(int, input().split())
courses = [input().strip() for _ in range(N)]


best_schedule, fitness = genetic_algorithm(N, T, courses)


print(''.join(map(str, best_schedule)))
print(fitness)

#TASK-2:
import random

def two_point_crossover(parent1, parent2):
    length = len(parent1)


    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)
</font>

    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2, point1, point2



def generate_population(pop_size, chromosome_length):
    population = []
    for _ in range(pop_size):
        chromosome = [random.randint(0, 1) for _ in range(chromosome_length)]
        population.append(chromosome)
    return population


def two_point_crossover_final(N, T, pop_size=10):

    chromosome_length = N * T
    population = generate_population(pop_size, chromosome_length)


    parent1, parent2 = random.sample(population, 2)


    offspring1, offspring2, point1, point2 = two_point_crossover(parent1, parent2)


    print("Parent 1: ", ''.join(map(str, parent1)))
    print("Parent 2: ", ''.join(map(str, parent2)))
    print(f"Two-point crossover between indices: {point1} and {point2}")
    print("Offspring 1:", ''.join(map(str, offspring1)))
    print("Offspring 2:", ''.join(map(str, offspring2)))



N, T = map(int, input().split())


two_point_crossover_final(N, T)</pre>
</body>
</html>
