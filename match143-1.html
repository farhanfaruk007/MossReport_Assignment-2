<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/24241280_SM_KAFI_ANAM_CSE422_07_Assignment02_Fall2024.py_-_S.M_Kafi_Anam.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/17/21201660_rafatshahriar_cse422_17_assignment02_fall2024_-_RAFAT_SHAHRIAR.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201660_rafatshahriar_CSE422_17_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1esjLtMwWS9ATTibrZfgsknCFu6ozvvVv
"""

import random

with open("input.txt", "r") as file:
    lines = file.readlines()

course_count, time_slot = map(int, lines[0].split())

<a name="3"></a><font color="#00FFFF"><a href="match143-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

course_list = [lines[i + 1].strip() for i in range(course_count)]

population_size = 100
mutation_rate = 0.5

def generate_population(size, course_count, time_slot):
</font>    return [[random.randint(0, 1) for _ in range(course_count * time_slot)] for _ in range(size)]

<a name="1"></a><font color="#00FF00"><a href="match143-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

def fitness(chromosome):
    overlap_penalty = 0
    consistency_penalty = 0

    for t in range(time_slot):
        timeslot_start = t * course_count
        timeslot_end = (t + 1) * course_count
        timeslot = chromosome[timeslot_start:timeslot_end]
        scheduled_courses = sum(timeslot)
        if scheduled_courses &gt; 1:
            overlap_penalty += (scheduled_courses - 1)

    schedule_count = [0] * course_count
    for t in range(time_slot):
        timeslot_start = t * course_count
        timeslot_end = (t + 1) * course_count
        timeslot = chromosome[timeslot_start:timeslot_end]
        for idx in range(len(timeslot)):
</font>            if timeslot[idx] == 1:
                schedule_count[idx] += 1

    for count in schedule_count:
        if count != 1:
            consistency_penalty += abs(count - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty

def sel_parents(population, fitness_values):
    min_fitness = min(fitness_values)
    if min_fitness &lt; 0:
        fitness_values = [f + abs(min_fitness) + 1 for f in fitness_values]
    return random.choices(population, weights=fitness_values, k=2)

def first_point_crossover(p1, p2):
    point = random.randint(1, len(p1) - 1)
    child1 = p1[:point] + p2[point:]
    child2 = p2[:point] + p1[point:]
    return child1, child2

def mutate(gen, mutation_rate):
    return [1 - gene if random.random() &lt; mutation_rate else gene for gene in gen]

<a name="0"></a><font color="#FF0000"><a href="match143-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

def genetic_algorithm(course_count, time_slot, population_size, mutation_rate):
    population = generate_population(population_size, course_count, time_slot)

    for generation in range(population_size):
        fitness_values = [fitness(gen) for gen in population]
        best_fitness = max(fitness_values)

        if best_fitness == 0:
            break

        new_population = []
        while len(new_population) &lt; population_size:
            p1, p2 = sel_parents(population, fitness_values)
            child1, child2 = first_point_crossover(p1, p2)
            new_population.append(mutate(child1, mutation_rate))
            new_population.append(mutate(child2, mutation_rate))
        population = new_population[:population_size]

    best_gen = population[fitness_values.index(max(fitness_values))]
    return best_gen, fitness(best_gen)
</font>

<a name="2"></a><font color="#0000FF"><a href="match143-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

def double_point_crossover(p1, p2):  # Two-point crossover function
    length = len(p1)
    point1, point2 = sorted(random.sample(range(length), 2))
    child1 = p1[:point1] + p2[point1:point2] + p1[point2:]
</font>    child2 = p2[:point1] + p1[point1:point2] + p2[point2:]
    return child1, child2, point1, point2

best_gen, best_fitness = genetic_algorithm(course_count, time_slot, population_size, mutation_rate)

population = generate_population(population_size, course_count, time_slot)
p1, p2 = random.sample(population, 2)
child1, child2, point1, point2 = double_point_crossover(p1, p2)

with open("output.txt", "w") as output_file:
    # Part 1:
    output_file.write("Part 1: Genetic Algorithm Results\n")
    output_file.write(f"Best Chromosome: {''.join(map(str, best_gen))}\n")
    output_file.write(f"Fitness Value: {best_fitness}\n\n")

    # Part 2:
    output_file.write("Part 2: Two-Point Crossover Results\n")
    output_file.write(f"Parent 1: {''.join(map(str, p1))}\n")
    output_file.write(f"Parent 2: {''.join(map(str, p2))}\n")
    output_file.write(f"1st Point: {point1}, 2nd Point: {point2}\n")
    output_file.write(f"Offspring 1: {''.join(map(str, child1))}\n")
    output_file.write(f"Offspring 2: {''.join(map(str, child2))}\n")</pre>
</body>
</html>
