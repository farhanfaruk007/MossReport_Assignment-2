<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/20301235_md_shamiul_islam_khan_ishrak_cse422_04_assignment02_fall2024_-_MD._SHAMIUL_ISLAM_KHAN_ISHRAK.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/20301235_md_shamiul_islam_khan_ishrak_cse422_04_assignment02_fall2024_-_MD._SHAMIUL_ISLAM_KHAN_ISHRAK.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20301235_Md.Shamiul Islam Khan Ishrak_CSE422_04_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V04cNpscwVtQvhSMlKDlDmnzPJ2AdU9D
"""

##Ishrak id 20301235

#part1
import random

def calculate_fitness(chromosome, N, T):
    overlap_penalty = 0
    consistency_penalty = 0

    for t in range(T):
        timeslot = chromosome[t * N:(t + 1) * N]
        overlap_penalty += max(0, sum(timeslot) - 1)


    for n in range(N):
        course_count = sum(chromosome[n + t * N] for t in range(T))
<a name="1"></a><font color="#00FF00"><a href="match211-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

        consistency_penalty += abs(course_count - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty


def select_parents(population):
    return random.sample(population, 2)

def single_point_crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
</font>    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2


def mutate(chromosome, mutation_rate=0.01):
    for i in range(len(chromosome)):
<a name="2"></a><font color="#0000FF"><a href="match211-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        if random.random() &lt; mutation_rate:
            chromosome[i] = 1 - chromosome[i]
    return chromosome


def genetic_algorithm(courses, N, T, population_size=100, max_generations=1000):

    population = [[random.randint(0, 1) for _ in range(N * T)] for _ in range(population_size)]
</font>
    for generation in range(max_generations):
        fitness_scores = [calculate_fitness(chromosome, N, T) for chromosome in population]

<a name="3"></a><font color="#00FFFF"><a href="match211-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        selected_population = [population[i] for i in sorted(range(len(fitness_scores)), key=lambda k: fitness_scores[k], reverse=True)[:population_size // 2]]

        next_generation = []
        while len(next_generation) &lt; population_size:
            parent1, parent2 = select_parents(selected_population)
            offspring1, offspring2 = single_point_crossover(parent1, parent2)
            next_generation.append(mutate(offspring1))
</font>            next_generation.append(mutate(offspring2))

        population = next_generation

    best_solution = max(population, key=lambda chromosome: calculate_fitness(chromosome, N, T))
    best_fitness = calculate_fitness(best_solution, N, T)

    return best_solution, best_fitness


def main():

    N = int(input("Enter the number of courses: "))
    T = int(input("Enter the number of timeslots: "))
    courses = [input(f"Enter course code {i+1}: ") for i in range(N)]


    best_solution, best_fitness = genetic_algorithm(courses, N, T)
    print("Best Schedule: ", ''.join(map(str, best_solution)))
    print("Fitness: ", best_fitness)

if __name__ == "__main__":
    main()

#part2
def perform_two_point_crossover(parent1, parent2, crossover_index1, crossover_index2):
    child1 = parent1[:crossover_index1] + parent2[crossover_index1:crossover_index2] + parent1[crossover_index2:]
<a name="0"></a><font color="#FF0000"><a href="match211-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

    child2 = parent2[:crossover_index1] + parent1[crossover_index1:crossover_index2] + parent2[crossover_index2:]

    return child1, child2


def demonstrate_crossover():
    first_parent = [0, 0, 0, 1, 1, 1, 0, 0, 0]
    second_parent = [1, 1, 1, 0, 0, 0, 1, 1, 1]
</font>
    crossover_point1 = 3
    crossover_point2 = 7

    offspring_a, offspring_b = perform_two_point_crossover(first_parent, second_parent, crossover_point1, crossover_point2)

    print("First Parent: ", ''.join(map(str, first_parent)))
    print("Second Parent: ", ''.join(map(str, second_parent)))
    print("First Offspring: ", ''.join(map(str, offspring_a)))
    print("Second Offspring: ", ''.join(map(str, offspring_b)))

if __name__ == "__main__":
    demonstrate_crossover()</pre>
</body>
</html>
