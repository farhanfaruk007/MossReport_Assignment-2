<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/22101024_angkon_dutta_joy_cse422_07_assignment02_fall2024_py_-_ANGKON_DUTTA_JOY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/22101024_angkon_dutta_joy_cse422_07_assignment02_fall2024_py_-_ANGKON_DUTTA_JOY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101024_Angkon Dutta Joy_CSE422_07_Assignment02_Fall2024.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11-csU_dmEQWwp5sJByqFyuBKQcxrQxlS

**Part - 1**
"""

import random

def generate_population(size, num_courses, num_time_slots):
    return [create_random_chromosome(num_courses, num_time_slots) for _ in range(size)]

def select_parent(population, fitness_scores):
    total_fitness = sum(fitness_scores)
    selection_probabilities = [score / total_fitness for score in fitness_scores]
    return random.choices(population, weights=selection_probabilities, k=1)[0]

def create_random_chromosome(num_courses, num_time_slots):
    chromosome = [random.choice([0, 1]) for _ in range(num_courses * num_time_slots)]
    if all(gene == 0 for gene in chromosome):
        chromosome[random.randint(0, num_courses * num_time_slots - 1)] = 1
    return chromosome

def combine_parents(p1, p2):
    split_point = random.randint(1, len(p1) - 1)
    child1 = p1[:split_point] + p2[split_point:]
    child2 = p2[:split_point] + p1[split_point:]
    return child1, child2

def apply_mutation(chromosome, mutation_probability=0.05):
    for index in range(len(chromosome)):
        if random.random() &lt; mutation_probability:
            chromosome[index] = 1 - chromosome[index]
    return chromosome

def genetic_optimization_algo(num_courses, num_time_slots, generations=100, population_size=20, mutation_probability=0.04):
    population = generate_population(population_size, num_courses, num_time_slots)
    best_chromosome = None
    highest_fitness = float('-inf')

    for gen in range(generations):
<a name="2"></a><font color="#0000FF"><a href="match183-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        fitness_scores = [evaluate_solution(chromosome, num_courses, num_time_slots) for chromosome in population]
        for idx, score in enumerate(fitness_scores):
            if score &gt; highest_fitness:
                highest_fitness = score
                best_chromosome = population[idx]
        if highest_fitness == 0:
            break
        new_gen = []
</font>        while len(new_gen) &lt; population_size:
            p1 = select_parent(population, fitness_scores)
            p2 = select_parent(population, fitness_scores)
<a name="4"></a><font color="#FF00FF"><a href="match183-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

            child1, child2 = combine_parents(p1, p2)
            new_gen.append(apply_mutation(child1, mutation_probability))
            new_gen.append(apply_mutation(child2, mutation_probability))

        population = new_gen[:population_size]

    return best_chromosome, highest_fitness
</font>
def evaluate_solution(chromosome, num_courses, num_time_slots):
    penalty_for_overlap = 0
    penalty_for_inconsistency = 0

    for i in range(num_time_slots):
        timeslot_schedule = chromosome[i * num_courses : (i + 1) * num_courses]
        scheduled_courses = sum(timeslot_schedule)
<a name="3"></a><font color="#00FFFF"><a href="match183-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

        if scheduled_courses &gt; 1:
            penalty_for_overlap += scheduled_courses - 1

    for course in range(num_courses):
        scheduled_instances = sum(chromosome[course::num_courses])
        penalty_for_inconsistency += abs(scheduled_instances - 1)
</font>
    return -(penalty_for_overlap + penalty_for_inconsistency)

with open("input.txt", "r") as file:
    lines = file.readlines()

<a name="0"></a><font color="#FF0000"><a href="match183-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

num_courses, num_time_slots = map(int, lines[0].split())
courses = [line.strip() for line in lines[1:]]
optimal_chromosome, fitness_value = genetic_optimization_algo(num_courses, num_time_slots)
with open("output.txt", "w") as output_file:
    output_file.write(''.join(map(str, optimal_chromosome)) + "\n")
</font>    output_file.write(str(fitness_value) + "\n")

"""**Part - 2**"""

import random

def read_file(file_path):
    with open(file_path, 'r') as file:
        data = file.readlines()
    return int(data[0].split()[0]), int(data[0].split()[1]), [line.strip() for line in data[1:]]

def write_file(file_path, individual1, individual2, child1, child2):
    with open(file_path, 'w') as file:
        file.write(f"Individual 1: {''.join(map(str, individual1))}\n")
        file.write(f"Individual 2: {''.join(map(str, individual2))}\n")
        file.write(f"Child 1:      {''.join(map(str, child1))}\n")
        file.write(f"Child 2:      {''.join(map(str, child2))}\n")

def create_initial_population(size, gene_count):
    return [[random.randint(0, 1) for _ in range(gene_count)] for _ in range(size)]

def perform_two_point_crossover(individual1, individual2):
    length = len(individual1)
    crossover_point1 = random.randint(1, length - 2)
    crossover_point2 = random.randint(crossover_point1 + 1, length - 1)
    return (individual1[:crossover_point1] + individual2[crossover_point1:crossover_point2] + individual1[crossover_point2:],
            individual2[:crossover_point1] + individual1[crossover_point1:crossover_point2] + individual2[crossover_point2:])

input_file = "input.txt"
<a name="1"></a><font color="#00FF00"><a href="match183-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

output_file = "output2.txt"
number_of_courses, number_of_timeslots, course_list = read_file(input_file)
chromo_length = number_of_courses * number_of_timeslots
population_size = 10
population = create_initial_population(population_size, chromo_length)
parent1, parent2 = random.sample(population, 2)
child1, child2 = perform_two_point_crossover(parent1, parent2)
write_file(output_file, parent1, parent2, child1, child2)</font></pre>
</body>
</html>
