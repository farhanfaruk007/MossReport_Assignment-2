<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/21201770_amit_kumer_halder_cse422_07_assignment02_fall2024_-_AMIT_KUMER_HALDER.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/11/22101650_md_ashiqur_rahman_abir_cse422_11_lab_assignment2_fall2024_-_MD._ASHIQUR_RAHMAN_ABIR.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101650_Md_Ashiqur_Rahman_Abir_CSE422_11_Lab_Assignment2_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YYJVCjAWQmxEAVPgkeX7KHpWm32YTGEx

# **Part 1**
"""

import random

f1 = open("/content/input.txt", "r")
l = f1.readline()
n, t = map(int, l.strip().split())

def create_chromosome(n, t):
    chromosome = [1] * n + [0] * (n * t - n)
    random.shuffle(chromosome)
    return chromosome

def calculate_fitness(chromosome, n, t):
    overlap_penalty = 0
    consistency_penalty = 0

    # Overlap penalty
    for p in range(t):
<a name="1"></a><font color="#00FF00"><a href="match62-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_17.gif"/></a>

        time_slot = chromosome[p * n:(p + 1) * n]

        course_count = sum(time_slot)

        if course_count &gt; 1:
            overlap_penalty += (course_count - 1)

    # Consistency penalty
    course_totals = [0] * n
    for p in range(t):
        time_slot = chromosome[p * n:(p + 1) * n]

        for ch in range(n):
            course_totals[ch] += time_slot[ch]

    for total in course_totals:
        if total != 1:
            consistency_penalty += abs(total - 1)

    return -(overlap_penalty + consistency_penalty)

# Generate a chromosome
chromosome = create_chromosome(n, t)
fitness_score = calculate_fitness(chromosome, n, t)

print("chromosome: ", "".join(map(str, chromosome)))
print("fitness of chromosome: ", fitness_score)

population = []
</font>for _ in range(5000):
    chromosome = create_chromosome(n, t)
    population.append(chromosome)


fitness_scores = []
for ch in population:
    fitness = calculate_fitness(ch, n, t)
    fitness_scores.append(fitness)

<a name="0"></a><font color="#FF0000"><a href="match62-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

def select_parents(population, fitness_scores):
    return random.choices(population, k=2)

def crossover_single_point(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

parent1, parent2 = select_parents(population, fitness_scores)
child1, child2 = crossover_single_point(parent1, parent2)

print("First parent: ", "".join(map(str, parent1)))
print("Second parent: ", "".join(map(str, parent2)))
print("First child: ", "".join(map(str, child1)))
print("Second child: ", "".join(map(str, child2)))

def mutate_chromosome(chromosome, mutation_rate=0.1):
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
            # Flip the bit (0 -&gt; 1, 1 -&gt; 0)
            chromosome[i] = 1 - chromosome[i]

mutate_chromosome(child1)
mutate_chromosome(child2)

print("First mutated child: ", "".join(map(str, child1)))
print("Second mutated child: ", "".join(map(str, child2)))

def genetic_algorithm(num_courses, num_slots, population_size=10, max_generations=100):
    global population, fitness_scores
</font>
    generation = 0
<a name="3"></a><font color="#00FFFF"><a href="match62-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

    while generation &lt; max_generations and max(fitness_scores) &gt; 0:
        new_population = []
        for _ in range(population_size // 2):
            parent1, parent2 = select_parents(population, fitness_scores)
            child1, child2 = crossover_single_point(parent1, parent2)
            mutate_chromosome(child1)
            mutate_chromosome(child2)
            new_population.extend([child1, child2])

        population = new_population[:population_size]
</font>        fitness_scores = [calculate_fitness(chrom, num_courses, num_slots) for chrom in population]

        generation += 1

<a name="5"></a><font color="#FF0000"><a href="match62-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    best_fitness = max(fitness_scores)
    best_chromosome = population[fitness_scores.index(best_fitness)]
    return best_chromosome, best_fitness

best_chromosome, best_fitness = genetic_algorithm(n, t)
print("Best chromosome: ", "".join(map(str, best_chromosome)))
print("Fitness of best chromosome: ", best_fitness)
</font>
"""# **Part 2**"""

<a name="4"></a><font color="#FF00FF"><a href="match62-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

def two_point_crossover(parent1, parent2):
    crossover_point1, crossover_point2 = sorted(random.sample(range(1, len(parent1)), 2))  # Replaces `p1, p2`
    ch1 = parent1[:crossover_point1] + parent2[crossover_point1:crossover_point2] + parent1[crossover_point2:]
</font><a name="2"></a><font color="#0000FF"><a href="match62-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    ch2 = parent2[:crossover_point1] + parent1[crossover_point1:crossover_point2] + parent2[crossover_point2:]
    return ch1, ch2

parent1, parent2 = select_parents(population, fitness_scores)
ch1, ch2 = two_point_crossover(parent1, parent2)

print("First parent: ", "".join(map(str, parent1)))
print("Second parent: ", "".join(map(str, parent2)))
print("First child: ", ''.join(map(str, ch1)))
</font>print("Second child: ", "".join(map(str, ch2)))</pre>
</body>
</html>
