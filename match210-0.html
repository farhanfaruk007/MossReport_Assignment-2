<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/14/21301024_abrar_rahman_14_cse422_lab_assignment2_-_ABRAR_RAHMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/14/21301024_abrar_rahman_14_cse422_lab_assignment2_-_ABRAR_RAHMAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301024_Abrar_Rahman_14_CSE422_Lab_Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bb_fMoBXHB6XD26x5Y_ZqfU4kgMHVyHC
"""

import random
import numpy as np
with open('/content/input.txt') as file:
    data = file.read().splitlines()
rows, cols = map(int, data[0].split())
def calculate_fitness(grid, rows, cols):
    row_penalty = sum(max(0, sum(grid[i * cols:(i + 1) * cols]) - 1) for i in range(rows))
    reshaped_grid = np.reshape(grid, (rows, cols))
    col_penalty = np.sum(np.abs(np.sum(reshaped_grid, axis=0) - 1))
    return -(row_penalty + col_penalty)
def initialize_population(pop_size, rows, cols):
    return [np.random.randint(2, size=rows * cols).tolist() for _ in range(pop_size)]

def select_parents(population):
    return random.sample(population, 2)
def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2

def mutate(child, mutation_rate=0.01):
    for i in range(len(child)):
        if random.random() &lt; mutation_rate:
            child[i] = 1 - child[i]
    return child

def genetic_algorithm(rows, cols, population_size=10, max_generations=300, mutation_rate=0.01):
    population = initialize_population(population_size, rows, cols)
    best_solution = None
    best_fitness = float('-inf')

    for generation in range(max_generations):
        new_population = []
        for _ in range(population_size // 2):
            parent1, parent2 = select_parents(population)
            child1, child2 = crossover(parent1, parent2)
            mutate(child1, mutation_rate)
            mutate(child2, mutation_rate)
            new_population.extend([child1, child2])

        for individual in new_population:
            fitness = calculate_fitness(individual, rows, cols)
            if fitness &gt; best_fitness:
                best_fitness = fitness
                best_solution = individual

        population = new_population

    return best_solution, best_fitness

best_individual, best_fitness = genetic_algorithm(rows, cols)
output = ''.join(map(str, best_individual))

print(output)
print(best_fitness)

<a name="0"></a><font color="#FF0000"><a href="match210-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

import random

def create_initial_population(size_of_population, num_of_classes, num_of_slots):
    population_list = []
    for _ in range(size_of_population):
        individual = ''.join(random.choice('01') for _ in range(num_of_classes * num_of_slots))
        while '1' not in individual:
            individual = ''.join(random.choice('01') for _ in range(num_of_classes * num_of_slots))
        population_list.append(individual)
    return population_list

def choose_random_parents(population_list):
    return random.sample(population_list, 2)

def two_point_crossover(parent_a, parent_b):
    genome_length = len(parent_a)

    first_crossover_point = random.randint(1, genome_length - 2)
    second_crossover_point = random.randint(first_crossover_point + 1, genome_length - 1)
</font>
    offspring_a = (parent_a[:first_crossover_point] +
                   parent_b[first_crossover_point:second_crossover_point] +
                   parent_a[second_crossover_point:])
<a name="1"></a><font color="#00FF00"><a href="match210-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

    offspring_b = (parent_b[:first_crossover_point] +
                   parent_a[first_crossover_point:second_crossover_point] +
                   parent_b[second_crossover_point:])

    return offspring_a, offspring_b

num_classes = 3
num_slots = 3
population_size = 10

population_list = create_initial_population(population_size, num_classes, num_slots)

parent_a, parent_b = choose_random_parents(population_list)

offspring_a, offspring_b = two_point_crossover(parent_a, parent_b)

print("Parent A:", parent_a)
print("Parent B:", parent_b)
print("Offspring A:", offspring_a)
</font>print("Offspring B:", offspring_b)</pre>
</body>
</html>
