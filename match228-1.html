<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/21101165_miftahul_jannat_orpi_cse422_06_assignment02_fall2024_-_MIFTAHUL_JANNAT_ORPI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/8/21201307_momtaheena_chowdhury_08_a2_-_MOMTAHEENA_CHOWDHURY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201307_Momtaheena_chowdhury_08_a2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kJKHyy5c7_O3zvTbuVb7pZrVuYs1ajAc
"""

import random


def create_routine(all_crs,time_slots): #routine dibe
    schedule =[] #store tasks


    for course in range (all_crs):
        designate_slot=random.randint(0,time_slots-1)
        schedule.append((course,designate_slot))
    return schedule

def evaluate_routine(schedule,total_course,time_slots): #quality check of schdl

    time_count=(slot for slot in schedule)
    count_penalty = sum (count -1 for count in time_count.values() if count &gt; 1)

    count_course =(course for course,_ in schedule)
    consistency_penalty = sum(abs(count-1)for count in count_course.values())
    return(count_penalty + consistency_penalty)


def find_parent(population,fitness_val):
    total_fitness = sum(fitness_val)

    total_probs =[sum(fitness_val[:i+1])/total_fitness for i in range(len(fitness_val))]
    make_selection = random.random()

    for i,prob in enumerate(total_probs):
        if make_selection&lt;=prob:
            return population[i]

def create_crossover(parent1,parent2):
    crossover_point =random.randint(1,len(parent1)-1)
    child1 =parent1[:crossover_point]+parent2[crossover_point:]
    child2 =parent2[:crossover_point]+parent1[crossover_point:]

    return child1,child2

def apply_mutation(schedule, mutation_rate):

     return [1 - gene if random.random() &lt; mutation_rate else gene for gene in schedule]

def calculate_fitness(schedule, all_crs, time_slots):


    count_penalty = 0
    consistency_penalty = 0

    # each time e overlap check
    for time_slot in range(time_slots):
        slot_courses = schedule[time_slot * all_crs: (time_slot + 1) * all_crs]
        count_penalty += max(0, sum(slot_courses) - 1)

    # course schedule check
    for c in range(all_crs):
        if sum(schedule[c + time_slot * all_crs] for time_slot in range(time_slots)) != 1:
            consistency_penalty += 1

    return count_penalty + consistency_penalty


def create_population(size,all_crs, time_slots): ## Generate the initial population
    population =[]
    for i in range(size):
        chromosome = [random.randint(0, 1) for i in range(all_crs * time_slots)]
        population.append(chromosome)  # add chromosome


    return population

def calc_fitness_population(population, all_crs, time_slots): ## fitness count of pop
    return [calculate_fitness(chromosome,all_crs,time_slots) for chromosome in population]


def find_parents(population,fitness_val): # parent select best ta
     return random.choices(population, weights=fitness_val, k=2)


def nxt_population(population,fitness_val,mutation_rate):
    next_gen=[]
    while len(next_gen)&lt;len(population):
        parent1,parent2 = find_parents(population,fitness_val)
        child1,child2 =create_crossover(parent1,parent2)
        next_gen.append(apply_mutation(child1, mutation_rate))
        next_gen.append(apply_mutation(child2, mutation_rate))
    return next_gen[:len(population)]  # size of population
# Main genetic algorithm

def genetic_algo(all_crs,time_slots,max_generations=5000,population_size=200, mutation_rate=0.01):
    population=create_population(population_size,all_crs,time_slots)
    best_schedule =None


    best_fitness = -999999 #lowest int

    for generation in range (max_generations):
        fitness_val =calc_fitness_population(population,all_crs,time_slots)

        if max(fitness_val)==0: # Check if the solution is perfect
            break

        # Evolve the population
        population = nxt_population(population,fitness_val,mutation_rate)


   # Track the best solution
        for chromosome,fitness in zip(population,fitness_val):
            if fitness&gt; best_fitness:
                best_schedule,best_fitness = chromosome,fitness
    return best_schedule,best_fitness,population

# Input
<a name="1"></a><font color="#00FF00"><a href="match228-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

print("enter number of courses and timeslots:")
all_crs ,time_slots= map(int,input().split())

print("enter codEs:")
course_codes=[input().strip() for _ in range (all_crs)]
# for genetic algorithm1
final_schedule, fitness_value, final_population = genetic_algo(all_crs, time_slots)


</font>final_population = ["".join(map(str, chrom)) for chrom in final_population]
<a name="0"></a><font color="#FF0000"><a href="match228-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

final_population=["".join(map(str, chrom)) for chrom in final_population]
print("\nBinary String: {}".format("".join(map(str, final_schedule))))#dsiplay binary
print("Fitness Value: {}".format(fitness_value))

#task2
parent1, parent2 = random.sample(final_population,2)
def crossover_task(parent1, parent2):
    cutoff1 = random.randrange(0, len(parent1) - 2)
    cutoff2 = random.randrange(cutoff1 + 1, len(parent1) - 1)
</font>
    newchild1 = parent1[:cutoff1] + parent2[cutoff1:cutoff2] + parent1[cutoff2:]
<a name="2"></a><font color="#0000FF"><a href="match228-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    newchild2 = parent2[:cutoff1] + parent1[cutoff1:cutoff2] + parent2[cutoff2:]
    return newchild1, newchild2

newchild1, newchild2 = crossover_task(parent1, parent2)

print("print final results")
print(f"Parent 1: {parent1}")
print(f"Parent 2: {parent2}")
print(f"newchild 1: {newchild1}")
</font>print(f"newchild 2: {newchild2}")

</pre>
</body>
</html>
