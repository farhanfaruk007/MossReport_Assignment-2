<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/22101461_zayed_masum_03_lab_assignment02_fall2024_-_ZAYED_MASUM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/22101362_plabon_mondal_cse422_07_assignment02_fall2024_-_PLABON_MONDAL.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101362_Plabon Mondal_CSE422_07_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MnUcWnPcvq0csmok_lz_OIK0KKjGCHMf
"""

# PART_01:

import random

<a name="0"></a><font color="#FF0000"><a href="match12-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_49.gif"/></a>

file = open("input.txt", "r")
p, q = file.readline().split(" ")
num_courses_N = int(p)
num_timeslots_T = int(q)
chromo_length = num_courses_N * num_timeslots_T
chromosome_bits = [None] * (num_courses_N * num_timeslots_T)

# Select random 10 first chromo:
population_group = []
bit_choices = [0, 1]
for p in range(10):
    for q in range(len(chromosome_bits)):
        chromosome_bits[q] = random.choice(bit_choices)
    population_group.append(chromosome_bits)
# print(population_group)

# Fitness Function:
def calc_overlap_penalty(chromosome_bits):
    total = 0
    timeslot_penalty = []
    # Calculate overlap and no course selected penalties
    for p in range(0, len(chromosome_bits), num_timeslots_T):
        for q in range(num_courses_N):
            total += chromosome_bits[p + q]
        timeslot_penalty.append(total - 1)
        total = 0
    penalty_sum = 0
    for k in range(num_timeslots_T):
        if timeslot_penalty[k] != -1:
            penalty_sum += timeslot_penalty[k]
    return penalty_sum

def calc_consistency_penalty(chromosome_bits):
    total = 0
    course_penalty = []

    for q in range(num_courses_N):
        for p in range(0, len(chromosome_bits), num_timeslots_T):
            total += chromosome_bits[p + q]
        course_penalty.append(abs(total - 1))
        total = 0
    penalty_sum = 0
    for k in range(num_timeslots_T):
        penalty_sum += course_penalty[k]
    return penalty_sum

def fitness_evaluation(chromosome_bits):
    return (-1) * (calc_consistency_penalty(chromosome_bits) + calc_overlap_penalty(chromosome_bits))

def select_parents(population_group):
    parent_a, parent_b = random.sample(population_group, 2)
    return parent_a, parent_b

def single_point_crossover(parent_a, parent_b):
    C_one = []
    C_two = []
    crossover_point = random.randint(0, chromo_length - 1)
    # Create Child_one
    for q in range(0, crossover_point):
        C_one.append(parent_a[q])
    for q in range(crossover_point, num_courses_N * num_timeslots_T):
        C_one.append(parent_b[q])
    # Create Child_two
    for q in range(0, crossover_point):
        C_two.append(parent_b[q])
    for q in range(crossover_point, num_courses_N * num_timeslots_T):
        C_two.append(parent_a[q])
    return C_one, C_two

def apply_mutation(C_one, C_two):
    mutation_point_a = random.randint(0, chromo_length - 1)
    C_one[mutation_point_a] = random.choice(bit_choices)
    mutation_point_b = random.randint(0, chromo_length - 1)
    C_two[mutation_point_b] = random.choice(bit_choices)
    return C_one, C_two

def update_population(population_group):
    fitness_list = []
    for p in range(len(population_group)):
        chromo = population_group[p]
        fitness_list.append((fitness_evaluation(chromo), chromo))
    fitness_list.sort(reverse=True)
</font>    population_group.clear()
    for i in range(10):
        population_group.append(fitness_list[i][1])

# Genetic Algorithm
<a name="2"></a><font color="#0000FF"><a href="match12-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_15.gif"/></a>

def genetic_algorithm(population_group):
    parent_a, parent_b = select_parents(population_group)
    if fitness_evaluation(parent_a) == 0:
        return parent_a
    elif fitness_evaluation(parent_b) == 0:
        return parent_b
    C_one, C_two = single_point_crossover(parent_a, parent_b)
    mutated_a, mutated_b = apply_mutation(C_one, C_two)
    population_group.append(mutated_a)
    population_group.append(mutated_b)
    update_population(population_group)
    return None

found_solution = True
for p in range(100):
    r = genetic_algorithm(population_group)
    if r != None:
        for p in range(len(r)):
            print(r[p], end="")
        print()
        print("Fitness : ", 0)
        found_solution = False
        break

if found_solution:
    br = population_group[0]
    for p in range(len(br)):
        print(br[p], end="")
    print()
    print("Fitness : ", fitness_evaluation(population_group[0]))
</font>

# PART_02:

<a name="3"></a><font color="#00FFFF"><a href="match12-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_9.gif"/></a>

def two_point_crossover(population_group):

    parent_a, parent_b = select_parents(population_group)
    print("Parent A:", end=" ")
    for p in range(len(parent_a)):
        print(parent_a[p], end="")
    print()

    print("Parent B:", end=" ")
    for p in range(len(parent_b)):
        print(parent_b[p], end="")
    print()

    C_one = []
    C_two = []
    point_a = random.randint(0, chromo_length - 2)
    point_b = random.randint(point_a + 1, chromo_length - 1)
</font>    # print("Point A:", point_a)
    # print("Point B:", point_b)

    # Create C_one
<a name="1"></a><font color="#00FF00"><a href="match12-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_16.gif"/></a>

    for i in range(0, point_a):
        C_one.append(parent_a[i])
    for j in range(point_a, point_b + 1):
        C_one.append(parent_b[j])
    for k in range(point_b + 1, num_courses_N * num_timeslots_T):
        C_one.append(parent_a[k])

    # Create C_two
    for i in range(0, point_a):
        C_two.append(parent_b[i])
    for j in range(point_a, point_b + 1):
        C_two.append(parent_a[j])
    for k in range(point_b + 1, num_courses_N * num_timeslots_T):
        C_two.append(parent_b[k])
    print("Child A:", end=" ")
    for p in range(len(C_one)):
        print(C_one[p], end="")
    print()
    print("Child B:", end=" ")
    for p in range(len(C_two)):
        print(C_two[p], end="")
</font>
two_point_crossover(population_group)</pre>
</body>
</html>
