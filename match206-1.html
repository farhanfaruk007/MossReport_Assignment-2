<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/21141004_TanzinaAfrinLazika_CSE422_04_Assignment02_Fall2024.py.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/8/21201102_nahiyantabassum_08_422lab02_-_NAHIYAN_TABASSUM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201102_NahiyanTabassum_08_422Lab02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CJsdsaFKv8KK-QXftxlUJOkLUe8OhBFE
"""

import random

def calculate_fitness(chromosome, N, T):
    op_penalty = 0  # overlap penalty
    ct_penalty = 0  # consistency penalty

    # overlap penalty
    for t in range(T):
        timeslot = chromosome[t * N: (t + 1) * N] #iterationg from 0 to t... if n=3 then for slot1, t=0 so take 0,1,2 i...for slot2 take t=1 so 3,4,5 i etc
        scheduled_courses = sum(timeslot)
<a name="1"></a><font color="#00FF00"><a href="match206-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

        if scheduled_courses &gt; 1:
            op_penalty += scheduled_courses - 1  # given condition

    # consistency penalty
    for n in range(N):
        course_scheduled_times = sum(chromosome[n::N]) #slice with steps=N...so in 1st loop we get all binary values for 1st course; in 2nd loop we get for 2nd course etc
        if course_scheduled_times != 1:
            ct_penalty += abs(course_scheduled_times - 1)  # given

    total_penalty = op_penalty + ct_penalty  # given
    fitness_score = -total_penalty
    return fitness_score

def select_parents(population):
</font>    p1, p2 = random.sample(population, 2)  # select 2 parents from the population
    return p1, p2

def crossover(p1, p2):
    crossover_point = random.randint(1, len(p1) - 1)
    offspring1 = p1[:crossover_point] + p2[crossover_point:]
    offspring2 = p2[:crossover_point] + p1[crossover_point:]
    return offspring1, offspring2

def mutation(chromosome):
    mutated_chromosome = chromosome[:]
    flip = random.choice([1, 2])  # flip 1 or 2 bits?
    indexes = random.sample(range(len(mutated_chromosome)), flip)  # which indexes to flip?

    for i in indexes:
<a name="0"></a><font color="#FF0000"><a href="match206-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

        mutated_chromosome[i] = 1 - mutated_chromosome[i]  # flip the bit 0/1
    return mutated_chromosome

def genetic_algorithm(N, T, max_iter=1000):
    population_size = 100
    population = [[random.randint(0, 1) for i in range(N * T)] for j in range(population_size)] #generate random integer 0/1 of N*T length

    for iteration in range(max_iter):
        fitness_scores = [calculate_fitness(chromosome, N, T) for chromosome in population]

        if max(fitness_scores) == 0:
            break #terminate if the best schedule is already generated... no need to perform the algorithm tghen

        new_population = []  # store new chromosomes after crossover and mutation
        for p in range(population_size // 2):  #each iteration gives us 2 children so we iterate for half the time which is enough
            p1, p2 = select_parents(population)
</font>            offspring1, offspring2 = crossover(p1, p2)
            new_population = new_population + [mutation(offspring1), mutation(offspring2)]

        population = new_population

    fitness_scores = [calculate_fitness(chromo, N, T) for chromo in population]

    max_fitness_index = fitness_scores.index(max(fitness_scores))

    best_chromosome = population[max_fitness_index] #chromosome with the maximum fitness score
    best_fitness = fitness_scores[max_fitness_index]

    return best_chromosome, best_fitness



#inputs

N, T = map(int, input().strip().split())
course_codes = [input().strip() for n in range(N)]

'''
inputs are given in the following demo example way:

1st input : 3 3  (then press enter) (N*T format so it takes N inputs)
2nd input : cse110 (then press enter)
3rd input : cse220 (then press enter)
4th input : cse 330 (then press enter)

'''


if T &lt; N:
    print("T must be greater or equals to N")

else:

    best_schedule, best_fitness = genetic_algorithm(N, T)
    print("Best Schedule:", ''.join(map(str, best_schedule)))
    print("Fitness:", best_fitness)



    # TASK 2 - two-point crossover
    p1, p2 = select_parents([[random.randint(0, 1) for i in range(N * T)] for j in range(10)])

    def two_point_crossover(p1, p2):
        length = len(p1)
        point1 = random.randint(1, length - 2) #length -2 to avoid choosing the last index
        point2 = random.randint(point1 + 1, length - 1) #point1 + 1 so that the 2nd point is chosen after the first point

        offspring3 = p1[:point1] + p2[point1:point2] + p1[point2:]
        offspring4 = p2[:point1] + p1[point1:point2] + p2[point2:]

        return offspring3, offspring4

    offspring3, offspring4 = two_point_crossover(p1, p2)

    print("\nSelected parents for two-point crossover:")
    print("Parent 1:", ''.join(map(str, p1)))
    print("Parent 2:", ''.join(map(str, p2)))
    print("Offspring 3:", ''.join(map(str, offspring3)))
    print("Offspring 4:", ''.join(map(str, offspring4)))

</pre>
</body>
</html>
