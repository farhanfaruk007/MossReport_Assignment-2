<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/20201094_TahmidUddinProtim_Cse422_03_Lab_Assignment02_Fall2024_-_Tahmid_Uddin_Protim.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/20201094_TahmidUddinProtim_Cse422_03_Lab_Assignment02_Fall2024_-_Tahmid_Uddin_Protim.py<p></p><pre>
# -*- coding: utf-8 -*-
"""CSE422 Lab 02 - 20201094_TahmidUddinProtim_CSE422_03_Lab_Assignment02_Fall2024.py

Automatically generated by Colab.

<a name="2"></a><font color="#0000FF"><a href="match191-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/1MVVTgB5xvQh2j0HWGUTcVJEkVMk-gtXX
"""

#Sample Input
#3 3
#CSE110
#MAT110
#PHY112

import random

#Function to read input from file
def get_inp(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
</font>
    N, T = map(int, lines[0].split())
<a name="1"></a><font color="#00FF00"><a href="match191-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

    courses = [line.strip() for line in lines[1:N + 1]]

    return N, T, courses

N, T, courses = get_inp('input.txt')
print(f"Number of courses: {N}\nNumber of timeslots: {T}\nCourses: {courses}")

#Parameters
POPULATION_SIZE = 10
GENERATIONS = 100
ELITISM_RATE = 20  # Percentage

#Individual representation
class Individual:
    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.calculate_fitness()
</font>
    @staticmethod
    def generate_random():
        chromosome = ''.join(random.choice('01') for _ in range(N * T))
        while set(chromosome) == {'0'}:  # Ensure no all-zeros chromosome
            chromosome = ''.join(random.choice('01') for _ in range(N * T))
        return chromosome

    def calculate_fitness(self):
        ov_p, cons_p = 0, 0
        timeslots = [self.chromosome[i * N:(i + 1) * N] for i in range(T)]

        #Overpopulation penalty
        ov_p = sum(max(0, timeslot.count('1') - 1) for timeslot in timeslots)

        #Constraints penalty
        for i in range(N):
            count = sum(timeslot[i] == '1' for timeslot in timeslots)
            cons_p += abs(count - 1)

        return -(ov_p + cons_p)

    def mutate(self, rate=0.01):
        mutated = [
            '0' if bit == '1' else '1' if random.random() &lt; rate else bit
            for bit in self.chromosome
        ]
        return Individual(''.join(mutated))

    def crossover(self, partner):
        point1, point2 = sorted(random.sample(range(1, len(self.chromosome)), 2))
        child1 = self.chromosome[:point1] + partner.chromosome[point1:point2] + self.chromosome[point2:]
<a name="0"></a><font color="#FF0000"><a href="match191-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

        child2 = partner.chromosome[:point1] + self.chromosome[point1:point2] + partner.chromosome[point2:]
        return Individual(child1), Individual(child2)

#Selection function
def select_parents(population):
    total_fitness = sum(ind.fitness for ind in population)
    probabilities = [ind.fitness / total_fitness for ind in population]
    return random.choices(population, probabilities, k=2)
</font>
#Genetic Algorithm
def genetic_algorithm():
<a name="3"></a><font color="#00FFFF"><a href="match191-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    population = [Individual(Individual.generate_random()) for _ in range(POPULATION_SIZE)]
    print("INITIAL POPULATION CREATED")

    for generation in range(GENERATIONS):
        population.sort(key=lambda ind: ind.fitness, reverse=True)

        # Elitism
        elites_count = int((ELITISM_RATE / 100) * POPULATION_SIZE)
</font>        new_generation = population[:elites_count]

        # Crossover and Mutation
        while len(new_generation) &lt; POPULATION_SIZE:
            parents = select_parents(population)
            offspring = parents[0].crossover(parents[1])
            new_generation.extend(offspring[:2])

        population = [ind.mutate() for ind in new_generation[:POPULATION_SIZE]]

    best_individual = max(population, key=lambda ind: ind.fitness)
    print(best_individual.chromosome)
    print(best_individual.fitness)

if __name__ == '__main__':
    genetic_algorithm()</pre>
</body>
</html>
