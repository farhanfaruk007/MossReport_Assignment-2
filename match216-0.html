<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/20101052_Abrar_Zahin_CSE422_06_Assignment02_-_ABRAR_ZAHIN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/20101052_Abrar_Zahin_CSE422_06_Assignment02_-_ABRAR_ZAHIN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20101052_Abrar Zahin_CSE422_06_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qPRhH2neFCTgkDniyqrVMgtoDT_Csyn0
"""

#Task 1
import random

input_file = open("input.txt", 'r')
first_line = input_file.readline().strip()
num_courses, num_timeslots = map(int, first_line.split())
if num_timeslots &lt; num_courses:
  raise ValueError("Number of timeslots must be greater than or equal to the number of courses.")

courses = [input_file.readline().strip() for _ in range(num_courses)]

class ScheduleOptimizer:
    def __init__(self, num_courses, num_timeslots, population_size, max_generations, mutation_rate=0.1):
        self.num_courses = num_courses
<a name="0"></a><font color="#FF0000"><a href="match216-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

        self.num_timeslots = num_timeslots
        self.population_size = population_size
        self.max_generations = max_generations
        self.mutation_rate = mutation_rate
        self.population = self.initialize_population()

    def initialize_population(self):
        return [
            [random.randint(0, 1) for _ in range(self.num_courses * self.num_timeslots)]
            for _ in range(self.population_size)
        ]

    def run_genetic_algorithm(self):
</font>        best_fitness = float('-inf')
        best_chromosome = None
        current_generation = 0

        while current_generation &lt; self.max_generations:
            fitness_scores = [self.evaluate_fitness(chromosome) for chromosome in self.population]


            max_fitness = max(fitness_scores)
            if max_fitness &gt; best_fitness:
                best_fitness = max_fitness
                best_chromosome = self.population[fitness_scores.index(max_fitness)]


            new_population = []
<a name="2"></a><font color="#0000FF"><a href="match216-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            while len(new_population) &lt; self.population_size:
                parent1, parent2 = self.select_parents(fitness_scores)
                child1, child2 = self.crossover(parent1, parent2)
                new_population.append(self.mutate(child1))
                new_population.append(self.mutate(child2))

            self.population = new_population
</font>            current_generation += 1

        return best_chromosome, best_fitness

    def evaluate_fitness(self, chromosome):
        overlap_penalty = 0
        consistency_penalty = 0


        for t in range(self.num_timeslots):
            timeslot = chromosome[t * self.num_courses:(t + 1) * self.num_courses]
            overlap = sum(timeslot)
            if overlap &gt; 1:
                overlap_penalty += (overlap - 1)


        for course in range(self.num_courses):
            occurrences = sum(chromosome[course + t * self.num_courses] for t in range(self.num_timeslots))
            consistency_penalty += abs(occurrences - 1)

        return -(overlap_penalty + consistency_penalty)

    def select_parents(self, fitness_scores):
        total_fitness = sum(fitness_scores)
        probabilities = [fitness / total_fitness for fitness in fitness_scores]
        parent1 = random.choices(self.population, weights=probabilities, k=1)[0]
        parent2 = random.choices(self.population, weights=probabilities, k=1)[0]
        return parent1, parent2

    def crossover(self, parent1, parent2):
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = parent1[:crossover_point] + parent2[crossover_point:]
<a name="1"></a><font color="#00FF00"><a href="match216-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        child2 = parent2[:crossover_point] + parent1[crossover_point:]
        return child1, child2

    def mutate(self, chromosome):
        return [
            1 - gene if random.random() &lt; self.mutation_rate else gene
            for gene in chromosome
</font>        ]

population_size = 20
max_generations = 1000

optimizer = ScheduleOptimizer(num_courses, num_timeslots, population_size, max_generations)
best_solution, best_fitness = optimizer.run_genetic_algorithm()

print(best_solution)
print("Fitness:", best_fitness)

#Task 2

import random
import numpy as np

def select_random_parents(population: np.ndarray) -&gt; tuple:
  selected_indices = np.random.choice(len(population), size=2, replace=False)
  return population[selected_indices[0]], population[selected_indices[1]]

def perform_two_point_crossover(parent1: np.ndarray, parent2: np.ndarray) -&gt; tuple:


    crossover_point1 = np.random.randint(1, len(parent1) - 1)
    crossover_point2 = np.random.randint(crossover_point1 + 1, len(parent1))


    offspring1 = np.concatenate([
        parent1[:crossover_point1],
        parent2[crossover_point1:crossover_point2],
        parent1[crossover_point2:]
    ])
    offspring2 = np.concatenate([
        parent2[:crossover_point1],
        parent1[crossover_point1:crossover_point2],
        parent2[crossover_point2:]
    ])

    return offspring1, offspring2

def run_genetic_algorithm(population: np.ndarray) -&gt; None:


    parent1, parent2 = select_random_parents(population)


    offspring1, offspring2 = perform_two_point_crossover(parent1, parent2)


    print("Offspring 1:", offspring1)
    print("Offspring 2:", offspring2)


initial_population_size = 10
chromosome_length = 9
population = np.random.randint(0, 2, size=(initial_population_size, chromosome_length))


run_genetic_algorithm(population)</pre>
</body>
</html>
