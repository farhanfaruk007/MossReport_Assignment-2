<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/20301058_farhan_fuad_cse422_04_assignment02_fall2024_-_FARHAN_FUAD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/20301058_farhan_fuad_cse422_04_assignment02_fall2024_-_FARHAN_FUAD.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20301058_Farhan Fuad_CSE422_04_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uq5Cb8YrincHm5AiyoXMy8NNlbtxSgPt
"""

<a name="2"></a><font color="#0000FF"><a href="match17-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_17.gif"/></a>

import numpy as np

class GeneticAlgo:
    def __init__(self):
        self.N = 0
        self.T = 0
        self.max_generation = 100
        self.target_fitness = 0
        self.population_size = 5
        self.mutation_probability = 0.1
        self.population = None
        self.parent1 = None
        self.parent2 = None
        self.offspring1 = None
        self.offspring2 = None

    def segment_time(self):
        self.N, self.T = map(int, input("Enter N (courses) and T (timeslots): ").strip().split())

    def build_chromosome(self, population_size=5):
        self.population = np.array([np.random.randint(0, 2, size=(self.N, self.T)) for _ in range(population_size)])
        return self.population

    def penalty(self, chromosome):
        overlap_penalty = 0
        course_count = np.zeros(self.N)
</font>
        # Overlap penalty
        time_slot = 0
        while time_slot &lt; self.T:
            overlap_penalty += max(0, np.sum(chromosome[:, time_slot]) - 1)
            time_slot += 1

        # Consistency penalty
<a name="1"></a><font color="#00FF00"><a href="match17-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

        course_count = np.sum(chromosome, axis=1)
        consistency_penalty = np.sum(np.abs(course_count - 1))

        total_penalty = overlap_penalty + consistency_penalty
        return -total_penalty

    def random_selection(self):
        if self.population is None:
            self.build_chromosome(self.population_size)

        indices = np.random.choice(self.population.shape[0], size=2, replace=False)
        self.parent1 = self.population[indices[0]]
        self.parent2 = self.population[indices[1]]

        print("Parent 1:")
        print(self.parent1)
        print("Parent 2:")
        print(self.parent2)

    def s_p_crossover(self):
        point_selection = np.random.randint(1, self.T)

        # Single-point crossover
        self.offspring1 = np.hstack((self.parent1[:, :point_selection], self.parent2[:, point_selection:]))
        self.offspring2 = np.hstack((self.parent2[:, :point_selection], self.parent1[:, point_selection:]))

        print(f"Random Crossover Point: {point_selection}")
        print("Offspring 1:")
        print(self.offspring1)
        print("Offspring 2:")
        print(self.offspring2)

    def mutate(self):
</font>        course_index = 0
        while course_index &lt; self.N:
            time_slot = 0
<a name="4"></a><font color="#FF00FF"><a href="match17-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

            while time_slot &lt; self.T:
                if np.random.rand() &lt; self.mutation_probability:
                    self.offspring1[course_index, time_slot] = 1 - self.offspring1[course_index, time_slot]
                    self.offspring2[course_index, time_slot] = 1 - self.offspring2[course_index, time_slot]
</font>                time_slot += 1
            course_index += 1

<a name="3"></a><font color="#00FFFF"><a href="match17-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

        print("Mutated Offspring 1:")
        print(self.offspring1)
        print("Mutated Offspring 2:")
        print(self.offspring2)

    def run(self):
        self.build_chromosome(self.population_size)

        best_fitness = float('-inf')
        best_chromosome = None
        generation = 0

        while generation &lt; self.max_generation:
            print(f"Generation: {generation}")
            generation += 1

            fitness_scores = []
</font>            i = 0
            while i &lt; len(self.population):
                fitness_scores.append(self.penalty(self.population[i]))
                i += 1

<a name="0"></a><font color="#FF0000"><a href="match17-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_32.gif"/></a>

            max_fitness = max(fitness_scores)
            if max_fitness &gt;= self.target_fitness:
                print("Target fitness reached!")
                best_fitness_idx = np.argmax(fitness_scores)
                best_fitness = max_fitness
                best_chromosome = self.population[best_fitness_idx]
                break

            best_fitness_idx = np.argmax(fitness_scores)
            if max_fitness &gt; best_fitness:
                best_fitness = max_fitness
                best_chromosome = self.population[best_fitness_idx]

            new_population = []
            while len(new_population) &lt; self.population_size:
                self.random_selection()
                self.s_p_crossover()
                self.mutate()
                new_population.append(self.offspring1)
                new_population.append(self.offspring2)

            self.population = np.array(new_population[:self.population_size])

        print(f"Best fitness after {generation} generations: {best_fitness}")
        print("Best chromosome (solution):")
        print(best_chromosome)

    def two_point_crossover(self):
        population = self.build_chromosome(self.population_size)
        self.parent1 = population[np.random.choice(range(self.population_size))]
        self.parent2 = population[np.random.choice(range(self.population_size))]

        point1, point2 = sorted(np.random.choice(range(1, self.T), size=2, replace=False))

        self.offspring1 = np.hstack((
            self.parent1[:, :point1],
            self.parent2[:, point1:point2],
            self.parent1[:, point2:]
        ))
        self.offspring2 = np.hstack((
            self.parent2[:, :point1],
            self.parent1[:, point1:point2],
            self.parent2[:, point2:]
        ))

        print(f"Random Crossover Points: {point1}, {point2}")
        print(f"Parent1:\n{self.parent1}\nParent2:\n{self.parent2}")
        print(f"Offspring1:\n{self.offspring1}\nOffspring2:\n{self.offspring2}")

print("Task 1")
Task1 = GeneticAlgo()
Task1.segment_time()
Task1.run()

print("Task 2")
Task2 = GeneticAlgo()
Task2.segment_time()
Task2.two_point_crossover()
</font>
</pre>
</body>
</html>
