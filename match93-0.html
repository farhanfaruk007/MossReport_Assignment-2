<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/9/23341115_yasinrahman_(2)_-_YASIN_RAHMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/9/23341115_yasinrahman_(2)_-_YASIN_RAHMAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""23341115_YasinRahman

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12nKncMH62UdPsMzQYKy2M0cTDSzseCsS
"""

import random

course_count = int(input("Enter the number of courses: "))
slot_count = int(input("Enter the number of time slots: "))

if slot_count &lt; course_count:
    raise ValueError("The number of slots must be equal to or greater than the number of courses.")


print(f"Enter the names of the {course_count} courses:")
course_names = [input(f"Course {i+1}: ").strip() for i in range(course_count)]

gene_length = course_count * slot_count

def calculate_fitness(schedule):
    overlap_issues = 0
    assignment_issues = 0

    slots = [schedule[i * course_count:(i + 1) * course_count] for i in range(slot_count)]

    for slot in slots:
<a name="3"></a><font color="#00FFFF"><a href="match93-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

        overlap_issues += max(0, sum(slot) - 1)

    assigned_courses = [0] * course_count
    for slot in slots:
        for j in range(course_count):
            if slot[j] == 1:
                assigned_courses[j] += 1

    assignment_issues += sum(abs(count - 1) for count in assigned_courses)
</font>    return -(overlap_issues + assignment_issues)

<a name="0"></a><font color="#FF0000"><a href="match93-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

def generate_population(size):
    group = []
    for _ in range(size):
        individual = [0] * gene_length
        for course in range(course_count):
            random_slot = random.randint(0, slot_count - 1)
            individual[random_slot * course_count + course] = 1
        group.append(individual)
    return group

def pick_parents(population, scores):
    selected = []
    for _ in range(2):
        competitors = random.sample(list(zip(population, scores)), 3)
</font>        best_candidate = max(competitors, key=lambda x: x[1])[0]
        selected.append(best_candidate)
<a name="5"></a><font color="#FF0000"><a href="match93-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    return selected

def perform_crossover(parent_a, parent_b):
    split_point = random.randint(1, gene_length - 1)
    child_a = parent_a[:split_point] + parent_b[split_point:]
</font>    child_b = parent_b[:split_point] + parent_a[split_point:]
    return child_a, child_b

def mutate_chromosome(chromosome, rate):
    for i in range(gene_length):
        if random.random() &lt; rate:
            chromosome[i] = 1 - chromosome[i]

def genetic_solver(pop_size, mutation_rate, max_cycles):
<a name="4"></a><font color="#FF00FF"><a href="match93-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

    population = generate_population(pop_size)
    best_score = float('-inf')
    best_candidate = None

    for cycle in range(max_cycles):
        fitness_values = [calculate_fitness(candidate) for candidate in population]
        next_gen = []

        for _ in range(pop_size // 2):
            parent_a, parent_b = pick_parents(population, fitness_values)
</font>            offspring_a, offspring_b = perform_crossover(parent_a, parent_b)
<a name="2"></a><font color="#0000FF"><a href="match93-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

            mutate_chromosome(offspring_a, mutation_rate)
            mutate_chromosome(offspring_b, mutation_rate)
            next_gen.extend([offspring_a, offspring_b])

        population = next_gen
        fitness_values = [calculate_fitness(candidate) for candidate in population]
        highest_score = max(fitness_values)
        top_chromosome = population[fitness_values.index(highest_score)]

        if highest_score &gt; best_score:
            best_score = highest_score
            best_candidate = top_chromosome

    return best_candidate, best_score

pop_size = 100
mutation_rate = 0.01
</font>max_generations = 1000

<a name="1"></a><font color="#00FF00"><a href="match93-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

final_solution, final_score = genetic_solver(pop_size, mutation_rate, max_generations)

print("Optimal Schedule:", ''.join(map(str, final_solution)))
print("Optimal Fitness Score:", final_score)

import random

def create_population(size, gene_length):
    group = []
    for _ in range(size):
        individual = [random.randint(0, 1) for _ in range(gene_length)]
        group.append(individual)
    return group

def perform_two_point_crossover(parent_a, parent_b):
    gene_size = len(parent_a)
    cut1 = random.randint(1, gene_size - 2)
    cut2 = random.randint(cut1 + 1, gene_size - 1)
</font>
    child1 = parent_a[:cut1] + parent_b[cut1:cut2] + parent_a[cut2:]
    child2 = parent_b[:cut1] + parent_a[cut1:cut2] + parent_b[cut2:]

    return child1, child2

course_count = int(input("Enter the total number of courses (N): "))
time_slots = int(input("Enter the total number of time slots (T): "))

if time_slots &lt; course_count:
    raise ValueError("Time slots (T) must not be fewer than courses (N).")

<a name="6"></a><font color="#00FF00"><a href="match93-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

gene_length = course_count * time_slots
population_size = 10

initial_population = create_population(population_size, gene_length)
parent_a, parent_b = random.sample(initial_population, 2)
child1, child2 = perform_two_point_crossover(parent_a, parent_b)
</font>
print("Parent A:", ''.join(map(str, parent_a)))
print("Parent B:", ''.join(map(str, parent_b)))
print("Child 1:", ''.join(map(str, child1)))
print("Child 2:", ''.join(map(str, child2)))</pre>
</body>
</html>
