<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/2/24141119_lab2_sec2_-_K_M_ABRAR_AHSAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/2/24141119_lab2_sec2_-_K_M_ABRAR_AHSAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141119_Lab2_Sec2.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ygpotyRHAUh9JTsmhIcOYqCb5a9gvHto
"""

import random

def fitness(chor, n, t):
    timeslots = []
    for i in range(t):
<a name="2"></a><font color="#0000FF"><a href="match26-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_19.gif"/></a>

        start_index = i * n
        end_index = (i + 1) * n
        chrom = chor[start_index:end_index]
        timeslots.append(chrom)

    overlap_penalty = 0
    for i in timeslots:
        scheduled_courses = sum(i)
        if scheduled_courses &gt; 1:
            overlap_penalty += scheduled_courses - 1

    course_count = [0] * n
    for j in timeslots:
        for i in range(n):
            course_count[i] += j[i]

    consistency_penalty = 0
    for i in course_count:
        consistency_penalty += abs(i - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty


def generate_chor(n, t):
    chor = []
    for i in range(n * t):
        chor.append(random.randint(0, 1))
    while sum(chor) == 0:
        chor = [random.randint(0, 1) for i in range(n * t)]
</font><a name="1"></a><font color="#00FF00"><a href="match26-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

    return chor

def genetic_algorithm(n, t, courses, max_generations=100, population_size=20, mutation_rate=0.01): #questione deya ache gen
    population = []
    for i in range(population_size):
        population.append(generate_chor(n, t))

    for k in range(max_generations):
        fitness_scores = []
        for individual in population:
            score = fitness(individual, n, t)
            fitness_scores.append(score)

        if max(fitness_scores) == 0:
            best_chor = population[fitness_scores.index(max(fitness_scores))]
            return best_chor, 0

        new_population = []
        while len(new_population) &lt; population_size:
            parent1, parent2 = slct_prnt(population, fitness_scores)
            offspring1, offspring2 = crossover(parent1, parent2)
            new_population.append(mutate(offspring1, mutation_rate))
            new_population.append(mutate(offspring2, mutation_rate))

    population = new_population[:population_size]

    fitness_scores = []
    for individual in population:
        score = fitness(individual, n, t)
        fitness_scores.append(score)

    best_chor = population[fitness_scores.index(max(fitness_scores))]
    return best_chor, max(fitness_scores)

def slct_prnt(population, fitness_scores):
    total_fitness = sum(fitness_scores)
    selection_probs = []
</font><a name="3"></a><font color="#00FFFF"><a href="match26-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>


    for score in fitness_scores:
        selection_probs.append(score / total_fitness)

    parents = random.choices(population, weights=selection_probs, k=2)
    return parents



def mutate(chor, mutation_rate=0.01):
</font>    for i in range(len(chor)):
        if random.random() &lt; mutation_rate:
            chor[i] = 1 - chor[i]
    return chor

def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2

def two_point_crossover(parent1, parent2):
    length = len(parent1)

    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)

    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
<a name="0"></a><font color="#FF0000"><a href="match26-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_26.gif"/></a>

    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2, point1, point2


##########input part######################
n,t = map(int, input("Input: ").split())
courses = []
for i in range(n):
    course_code = input().strip()
    courses.append(course_code)


population_size = 4
population = []
for i in range(population_size):
    chor = generate_chor(n, t)
    population.append(chor)

fitness_scores = []
for i in range(len(population)):
    fit = fitness(population[i], n, t)
    fitness_scores.append(fit)

print("Parents and their Fitness Values:")
for i in range(len(population)):
    print(f"chor {i+1}: {''.join(map(str, population[i]))}, Fitness: {fitness_scores[i]}")
print()

index1 = random.randint(0, len(population) - 1)
index2 = random.randint(0, len(population) - 1)
while index2 == index1:
    index2 = random.randint(0, len(population) - 1)

parent1 = population[index1]
parent2 = population[index2]

offspring1, offspring2, point1, point2 = two_point_crossover(parent1, parent2)

print("Parent 1:", "".join(map(str, parent1)))
print("Parent 2:", "".join(map(str, parent2)))
print(f"Two points: {point1}, {point2}")
print("Offspring 1:", "".join(map(str, offspring1)))
</font>print("Offspring 2:", "".join(map(str, offspring2)))</pre>
</body>
</html>
