<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/24241294_cse422_10_labassignment2_-_NAHIAN_QUADER_LABIB.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/24241369_cse422_10_labassignment2_-_LAMIA_SAIYARA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24241369_CSE422_10_LabAssignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xG6AreGuaxvADtOUNifsucx7jgt8i1Ro
"""

import random
#part 1


total_c = int(input("Enter total number of courses: "))
total_slot = int(input("Enter total number of timeslots: "))
print("Enter the course codes:")
courselist = [input().strip() for i in range(total_c)]

population = 5
total_generations = 2

<a name="2"></a><font color="#0000FF"><a href="match129-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

def schedule(total_c, total_slot):
  routine = [[0 for i in range(total_c)] for j in range(total_slot)]
  for k in range(total_c):
    random_slot = random.randint(0, total_slot-1)
    routine[random_slot][k] = 1
  return routine

def to_string(routine):
  return ''.join(str(j) for i in routine for j in i)

def to_int(chromosome, total_c):
</font>  return [list(map(int,chromosome[i:i+total_c])) for i in range(0, len(chromosome), total_c)]

<a name="1"></a><font color="#00FF00"><a href="match129-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

def fitness_function(routine, total_c, total_slot):
  overlap = 0
  consistency = 0

  for i in routine:
    overlap += max(0, sum(i) - 1)

  excess_number = [0] * total_c
  for i in routine:
    for j, k in enumerate(i):
      if k:
        excess_number[j] += 1
  consistency = sum(abs(i-1) for i in excess_number)
  return -(overlap + consistency)

def single_crossover(p1, p2):
</font>  crossover_point = random.randint(1, len(p1)-1)
  child1 = p1[:crossover_point] + p2[crossover_point:]
  child2 = p2[:crossover_point] + p1[crossover_point:]
  return child1, child2

def mutation(child, rate = 0.02):
  child = list(child)
  for i in range(len(child)):
    if random.random() &lt; rate:
      child[i] = '0' if child[i] == '1' else '1'
  return ''.join(child)



def g_algo(total_c, total_slot, population, total_generations ):
  initial_population = [to_string(schedule(total_c, total_slot)) for i in range(population)]
  initial_part2 = initial_population.copy()
  optimal_fitness = float('-inf')
  optimal_chromosome = None

  for i in range(total_generations):
    fitness_values = [fitness_function(to_int(i, total_c), total_c, total_slot) for i in initial_population]

    current_best_fitness = max(fitness_values)
    current_best_index = fitness_values.index(current_best_fitness)
<a name="0"></a><font color="#FF0000"><a href="match129-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

    current_best_chromosome = initial_population[current_best_index]

    if current_best_fitness &gt; optimal_fitness:
      optimal_fitness = current_best_fitness
      optimal_chromosome = current_best_chromosome

    print(f"Generation {i+1}: Best Fitness = {current_best_fitness}")

    if optimal_fitness == 0:
      print("Optimal solution found!")
      break

    children = []
    while len(children) &lt; population:
      p1, p2 = random.sample(initial_population, 2)
      child1, child2 = single_crossover(p1, p2)

      child1 = mutation(child1)
      child2 = mutation(child2)

      children.extend([child1, child2])

    initial_population = children[:population]

  return initial_part2, initial_population, optimal_chromosome, optimal_fitness





initial_part2, final_population, fittest_chromosome, best_value = g_algo(total_c, total_slot, population, total_generations)
</font>print("\nBest Schedule:")
print(fittest_chromosome)
print("Fitness Value:", best_value)

#part 2

def two_point(p1, p2):
  crossover_point1, crossover_point2 = sorted(random.sample(range(1, len(p1)), 2))
  child1 = p1[:crossover_point1] + p2[crossover_point1:crossover_point2] + p1[crossover_point2:]
<a name="3"></a><font color="#00FFFF"><a href="match129-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

  child2 = p2[:crossover_point1] + p1[crossover_point1:crossover_point2] + p2[crossover_point2:]

  return child1, child2

p1, p2 = random.sample(initial_part2, 2)
child1, child2 = two_point(p1, p2)
print("\nTwo point crossover:")
print("Parent 1:", p1)
print("Parent 2:", p2)
print("Child1:", child1)
</font>print("Child2:", child2)</pre>
</body>
</html>
