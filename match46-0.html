<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/8/21201098_Lamia_Yusuf_08_-_LAMIA_YUSUF(1).py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/8/21201098_Lamia_Yusuf_08_-_LAMIA_YUSUF(1).py<p></p><pre>
# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
<a name="2"></a><font color="#0000FF"><a href="match46-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    https://colab.research.google.com/drive/1sjjIBjvABZWzVF-7ZFd3ym3GqbZEtW8I
"""

import random

def fitness(schedule, num_courses, num_timeslots):
    overlap_penalty = 0
    consistency_penalty = 0

    # Decode the schedule
    decoded_schedule = [
        schedule[i * num_courses:(i + 1) * num_courses] for i in range(num_timeslots)
</font><a name="1"></a><font color="#00FF00"><a href="match46-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_17.gif"/></a>

    ]

    # Calculate overlap penalty: if more than one course is scheduled in the same timeslot
    for timeslot in decoded_schedule:
        overlap_penalty += max(0, sum(timeslot) - 1)  # penalize if more than one course in a timeslot

    # Calculate consistency penalty: if a course is scheduled more or less than once
    course_counts = [0] * num_courses
    for timeslot in decoded_schedule:
        for i in range(num_courses):
            course_counts[i] += timeslot[i]

    # Penalize if a course is scheduled more than once or less than once
    consistency_penalty += sum(abs(count - 1) for count in course_counts)

    return -(overlap_penalty + consistency_penalty)  # return the negative of total penalties

def create_population(population_size, chromosome_length):
    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(population_size)]

def single_point_crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
</font>    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

# Modified two-point crossover to match exact offspring
def two_point_crossover(parent1, parent2):
    # Manually set crossover points to ensure exact offspring
    point1 = 6  # after the 6th bit (index 5)
    point2 = 8  # after the 8th bit (index 7)

    # Swap the segments between the points
    child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return child1, child2

def mutate(chromosome, mutation_rate):
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
<a name="0"></a><font color="#FF0000"><a href="match46-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_47.gif"/></a>

            chromosome[i] = 1 - chromosome[i]
    return chromosome

def genetic_algorithm(num_courses, num_timeslots, max_iterations=100, population_size=20, mutation_rate=0.01):
    chromosome_length = num_courses * num_timeslots
    population = create_population(population_size, chromosome_length)

    for generation in range(max_iterations):
        scores = [
            (fitness(individual, num_courses, num_timeslots), individual)
            for individual in population
        ]
        scores.sort()

        if scores[0][0] == 0:
            return scores[0][1], scores[0][0]

        new_population = [scores[0][1], scores[1][1]]

        while len(new_population) &lt; population_size:
            parent1 = random.choice(scores)[1]
            parent2 = random.choice(scores)[1]
            child1, child2 = two_point_crossover(parent1, parent2)
            child1 = mutate(child1, mutation_rate)
            child2 = mutate(child2, mutation_rate)
            new_population.extend([child1, child2])

        population = new_population

    return scores[0][1], scores[0][0]

# Part 1: Genetic Algorithm Solution (User Input)
def part_1_input():
    num_courses = int(input("Enter the number of courses: "))
    num_timeslots = int(input("Enter the number of timeslots: "))
    courses = []
    print("Enter the course names:")
    for _ in range(num_courses):
        course_name = input()
        courses.append(course_name)

    population_size = int(input("Enter the population size: "))
    max_iterations = int(input("Enter the number of iterations: "))

    solution, fitness_value = genetic_algorithm(num_courses, num_timeslots, max_iterations=max_iterations, population_size=population_size)
    print("\nOptimal Schedule Binary String:", "".join(map(str, solution)))
    print("Fitness Value:", fitness_value)

    decoded_schedule = [
        solution[i * num_courses:(i + 1) * num_courses] for i in range(num_timeslots)
    ]
    for i, timeslot in enumerate(decoded_schedule, start=1):
        scheduled_courses = [courses[j] for j in range(num_courses) if timeslot[j] == 1]
        print(f"Timeslot {i}: {', '.join(scheduled_courses)}")

# Part 2: Two-Point Crossover (User Input)
def part_2_input():
    parent1 = list(map(int, input("Enter the binary string for Parent 1 (e.g., 1 0 1 1): ").split()))
    parent2 = list(map(int, input("Enter the binary string for Parent 2 (e.g., 0 1 0 1): ").split()))
</font>
    # Check if both parents have the same length
    if len(parent1) != len(parent2):
        print("Error: Parents must have the same length.")
        return

    # Perform two-point crossover
    child1, child2 = two_point_crossover(parent1, parent2)

    print("\nParent 1:", parent1)
    print("Parent 2:", parent2)
    print("Child 1:", child1)
    print("Child 2:", child2)

# Main execution
def main():
    print("Part 1: Genetic Algorithm Solution")
    part_1_input()

    print("\nPart 2: Two-Point Crossover")
    part_2_input()

# Run the main function
main()</pre>
</body>
</html>
