<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/22201567_rafi_al_mahmud_cse422_12_assignment02_fall2024_-_RAFI_AL_MAHMUD(1).py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/22201567_rafi_al_mahmud_cse422_12_assignment02_fall2024_-_RAFI_AL_MAHMUD(1).py<p></p><pre>
# -*- coding: utf-8 -*-
"""ID: 22201567_Rafi Al Mahmud_CSE422_12_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wAYoyFkpXw5MCtUuQ-sTA7pqsmV-d63Q
"""

import random
def initializing(length,n,t):
  population=[]
  for x in range(length):
    new=""
    for i in range(n*t):
      new+=str(random.randint(0,1))
    population.append(new)
  return population

def fitness_check(chromosome, n, t):
  overlap = 0
  con = 0

  for i in range(t):
    timeslot = chromosome[i * n:(i + 1) * n]
<a name="1"></a><font color="#00FF00"><a href="match123-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

    count = timeslot.count("1")
    if count &gt; 1:
       overlap += count - 1

  for i in range(n):
    count = 0
    for j in range(t):
      if chromosome[i * n + j] == "1":
        count += 1
    if count != 1:
      con += abs(count - 1)

  total = overlap + con
  return -total

def single_point_crossover(parent1, parent2):
</font>    crossover_point = random.randint(1, len(parent1) - 1)

    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]

    return offspring1, offspring2

def mutation(chromosome, rate):
    m_chromosome = list(chromosome)
    for gene_index in range(len(m_chromosome)):
        if random.random() &lt; rate:
            if m_chromosome[gene_index] == "1":
                m_chromosome[gene_index] = "0"
            else:
                m_chromosome[gene_index] = "1"
    return "".join(m_chromosome)

def the_genetic_algo(n, t, length = 10, max_generations = 10, rate = 0.01):
<a name="0"></a><font color="#FF0000"><a href="match123-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

  population = initializing(length, n, t)
  the_solution = None
  the_fitness = float("-inf")
  for generation in range(max_generations):
    fitness_values = []
    for chromosome in population:
      fitness_values.append(fitness_check(chromosome, n, t))

    for chromosome, fit_val in zip(population, fitness_values):
      if fit_val &gt; the_fitness:
        the_fitness = fit_val
        the_solution = chromosome

    new_population = []
    while len(new_population) &lt; length:
      first_parent, second_parent = selection(population, fitness_values)
      first, second = single_point_crossover(first_parent, second_parent)
      new_population.extend([mutation(first, rate), mutation(second, rate)])

    population = new_population[:length]
  return the_solution, the_fitness
</font>
def gen_algo(n, t, length=10, max_generations=10, rate=0.01):
    population = initializing(length, n, t)
    best_solution = None
    best_fitness = float("-inf")
    for generation in range(max_generations):
        fitness_values = [fitness_check(chromosome, n, t) for chromosome in population]

<a name="3"></a><font color="#00FFFF"><a href="match123-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

        for chromosome, fitness_val in zip(population, fitness_values):
            if fitness_val &gt; best_fitness:
                best_fitness = fitness_val
                best_solution = chromosome

        new_population = []
        while len(new_population) &lt; length:
            parent1, parent2 = selection(population, fitness_values)

            offspring1, offspring2 = single_point_crossover(parent1, parent2)

            offspring1 = mutation(offspring1, rate)
</font>            offspring2 = mutation(offspring2, rate)

            new_population.extend([offspring1, offspring2])

        population = new_population[:length]

    return best_solution, best_fitness

def selection(population, fitness_values):
<a name="4"></a><font color="#FF00FF"><a href="match123-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

  total_fit = sum(fitness_values)
  pro = []
  for i in fitness_values:
    pro.append(i/total_fit)
  parents = random.choices(population, weights=pro, k=2)
  return parents
</font>
with open("input.txt", "r") as inputs, open("output.txt", "a") as outputs:
    line = inputs.readline().strip().split()
    num_c = int(line[0])
    num_t = int(line[1])

    course_names = []
    for i in range(num_c):
        course_line = inputs.readline().strip()
<a name="2"></a><font color="#0000FF"><a href="match123-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

        course_names.append(course_line)

    best_solution, best_fitness = gen_algo(num_c,num_t,)

    outputs.write("Genetic Algorithm Results:\n")
    outputs.write(f"Best Solution: {best_solution}\n")
    outputs.write(f"Best Fitness: {best_fitness}\n")

def two_point_crossover(parent1, parent2):
  first_point = random.randint(0, len(parent1) - 1)
  second_point = random.randint(first_point + 1, len(parent1))
</font>  first_child = parent1[:first_point] + parent2[first_point:second_point] + parent1[second_point:]
  second_child = parent2[:first_point] + parent1[first_point:second_point] + parent2[second_point:]
  return first_child, second_child</pre>
</body>
</html>
