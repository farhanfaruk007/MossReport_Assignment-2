<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/22101364_Md_Rahim_Bhuiyan_CSE422_07_Assignment02_Fall2024_-_MD_RAHIM_BHUIYAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/16/22101104_cse422_section_16_labassignment2__-_IFTE_KHARUL_ISLAM_NIHAL.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101104_CSE422_Section_16_LabAssignment2_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PZbxIRZCFaQxU_NlohxIPar9AhSKPAKu

Part 1
"""

import random

def population_set(chromosomes_number, N, T):                                                      # Create a random population set of chromosomes number
    population = []
    for j in range(chromosomes_number):
        chromosome_set = []
<a name="2"></a><font color="#0000FF"><a href="match111-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

        for i in range(N):
            timeslot = [0] * T
            timeslot[random.randint(0, T - 1)] = 1
            chromosome_set.extend(timeslot)
        population.append(chromosome_set)
    return population


def calculated_fitness(chromosome_set, N, T):

    calcu_overlap_penalty = 0
    for t in range(T):
        timeslot = chromosome_set[t * N:(t + 1) * N]
</font>        schedule_courses = sum(timeslot)
        if schedule_courses == 0:
            calcu_overlap_penalty += 1
<a name="0"></a><font color="#FF0000"><a href="match111-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_21.gif"/></a>

        elif schedule_courses &gt; 1:
            calcu_overlap_penalty += (schedule_courses - 1)
    # print(f"Overlap penalty: {calcu_overlap_penalty}")


    calcu_consistency_penalty = 0
    for n in range(N):
        schedule_times = sum(chromosome_set[n + t * N] for t in range(T))
        calcu_consistency_penalty += abs(schedule_times - 1)
    # print(f"Consistency penalty: {calcu_consistency_penalty}")


    T_penalty = calcu_overlap_penalty + calcu_consistency_penalty
    fitness = -T_penalty
    # print(f"Chromosome: {chromosome_set}, Total penalty: {T_penalty}, Fitness: {fitness}")
    return fitness


def choose_parents(population, fitness_value):

    T_fitness = sum(fitness_value)
    selected_parents = []
    while len(selected_parents) &lt; 2:
        choice = random.uniform(0, T_fitness)
        current = 0
        for chromosome_set, fitness in zip(population, fitness_value):
            current += fitness
            if current &gt; choice:
                selected_parents.append(chromosome_set)
                break
    return selected_parents

def crossover(p1, p2):

    point = random.randint(1, len(p1) - 1)
    offspring1 = p1[:point] + p2[point:]
</font>    offspring2 = p2[:point] + p1[point:]
    return offspring1, offspring2

def mutation(chromosome_set, mutation_rate):

    for i in range(len(chromosome_set)):
        if random.random() &lt; mutation_rate:
<a name="1"></a><font color="#00FF00"><a href="match111-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

            chromosome_set[i] = 1 - chromosome_set[i]  # Flip the bit
    return chromosome_set



def geneticAlgorithm(N, T,chromosomes_number=50,generations=500, mutation_rate=0.01):
    population = population_set(chromosomes_number, N, T)                                              # intialize the population set from upper

    for generate in range(generations):

        fitness_value = []
        for ch in population:
            fitness = calculated_fitness(ch, N, T)                                                     #calculated fitness of each chromosome set
            fitness_value.append(fitness)

        if max(fitness_value) == 0:
            break

        new_population = []                                                                              #Selection and reproduction
        for i in range(chromosomes_number // 2):

            p1, p2 = choose_parents(population, fitness_value)
            offspring1, offspring2 = crossover(p1, p2)
            new_population.extend([mutation(offspring1, mutation_rate), mutation(offspring2, mutation_rate)])

        population = new_population


    best_index = fitness_value.index(max(fitness_value))
    best_schedule = population[best_index]
    best_fitness = fitness_value[best_index]
    return ''.join(map(str, best_schedule)), best_fitness
</font>
# Input parameters
N = 3
T = 3
courses_taken = ["CSE110", "MAT110", "PHY112"]

# Run the genetic algorithm
best_schedule, best_fitness = geneticAlgorithm(N, T)

# Display results
print(best_schedule)
print(best_fitness)

"""Part 2

"""

p1 = [0, 0, 0, 1, 1, 1, 0, 0, 0]
p2 = [1, 1, 1, 0, 0, 0, 1, 1, 1]

def two_point_perform_crossover(p1,p2):
  length = len(p1)
  # print(length)
  point1 = random.randint(0,length-2)
  point2 = random.randint(point1 + 1, length-1)
  print("Point1 : ",point1)
  print("Point2 : ",point2)


  offspring1 = p1[:point1] + p2[point1:point2] + p1[point2:]
  offspring2 = p2[:point1] + p1[point1:point2] + p2[point2:]

  return offspring1,offspring2


offspring1, offspring2 = two_point_perform_crossover(p1,p2)
print("Parent 1:", p1)
print("Parent 2:", p2)
print("Child 1:", offspring1)
print("Child 2:", offspring2)</pre>
</body>
</html>
