<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/21301206_cse422_10_labassignment2_-_Nuzhat_Tahsin.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/21301206_cse422_10_labassignment2_-_Nuzhat_Tahsin.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301206_CSE422_10_LabAssignment2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PVEDZl_wgn_5bQVjGmEUxdUX9un8c93D
"""

import random

# Task 1
ncourses, slots = map(int, input("Enter number of courses and time slots, space-separated: ").split())
course_codes=[]
for i in range(ncourses):
    course_code = input(f"Enter course code {i+1}: ")
    course_codes.append(course_code)
population_size = 10
max_iterations = 100

def generate_population(size, length):
    population = []
    for i in range(size):
        chromosome = ''
        for j in range(length):
            chromosome += random.choice(['0', '1'])
        population.append(chromosome)
    return population

def fitness_calculation(chromosome, ncourses, slots):
    penalty_overlap = 0
    penalty_consistency = 0
    course_count = [0] * ncourses
    courses_assigned_per_slot = [0] * slots

    for timeslot in range(slots):
        for course in range(ncourses):
            index = timeslot * ncourses + course
            if chromosome[index] == '1':
                courses_assigned_per_slot[timeslot] += 1
                course_count[course] += 1

    # Checking overlap penalty
    for courses_assigned in courses_assigned_per_slot:
        if courses_assigned &gt; 1:
            penalty_overlap += courses_assigned - 1

    # Consistency penalty
    for count in course_count:
<a name="1"></a><font color="#00FF00"><a href="match181-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

        if count != 1:
            penalty_consistency += abs(count - 1)

    fitness = -(penalty_overlap + penalty_consistency)
    return fitness

def select_parents(population):
    return random.sample(population, 2)

def single_point_crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
</font>    offspring1 = parent1[0:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[0:crossover_point] + parent1[crossover_point:]
    return offspring1, offspring2

def mutation(chromosome):
    indexes = random.sample(range(len(chromosome)), 3)
    mutated_chromosome = ""
    for i in range(len(chromosome)):
        if i in indexes:
            if chromosome[i] == '0':
                mutated_chromosome += '1'
            else:
                mutated_chromosome += '0'
        else:
            mutated_chromosome += chromosome[i]
    return mutated_chromosome

<a name="4"></a><font color="#FF00FF"><a href="match181-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

def genetic_algorithm(ncourses, slots, population_size, max_iterations):
    chromosome_length = ncourses * slots
    population = generate_population(population_size, chromosome_length)

    for i in range(max_iterations):
        fitnesses = []
</font>        for chromosome in population:
            fitness = fitness_calculation(chromosome, ncourses, slots)
            fitnesses.append(fitness)

<a name="3"></a><font color="#00FFFF"><a href="match181-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        if max(fitnesses) == 0:
            best_fitness = max(fitnesses)
            best_chromosome = population[fitnesses.index(best_fitness)]
            return best_chromosome, best_fitness

        new_population = []
        for _ in range(int(population_size / 2)):
</font><a name="0"></a><font color="#FF0000"><a href="match181-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

            parent1, parent2 = select_parents(population)
            offspring1, offspring2 = single_point_crossover(parent1, parent2)
            new_population.append(mutation(offspring1))
            new_population.append(mutation(offspring2))

        population = new_population

    fitnesses = [fitness_calculation(chromosome, ncourses, slots) for chromosome in population]
    best_fitness = max(fitnesses)
    best_chromosome = population[fitnesses.index(best_fitness)]
    return best_chromosome, best_fitness

best_schedule, best_fitness = genetic_algorithm(ncourses, slots, population_size, max_iterations)
</font>
print("Best Schedule:", best_schedule)
print("Best Fitness:", best_fitness)

# Task 2

def two_point_crossover(parent1, parent2):
    if len(parent1) != len(parent2):
        print("Parents must be of the same length")
        return None, None

    point1 = random.randint(1, len(parent1) - 2)
    point2 = random.randint(point1 + 1, len(parent1) - 1)

    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
<a name="2"></a><font color="#0000FF"><a href="match181-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2, point1, point2
population = generate_population(population_size, ncourses * slots)
parent1, parent2 = select_parents(population)
offspring1, offspring2, point1, point2 = two_point_crossover(parent1, parent2)
</font>
print(f"Parent 1: {parent1}")
print(f"Parent 2: {parent2}")
print(f"1st point: {point1}")
print(f"2nd point: {point2}")
print(f"Offspring 1: {offspring1}")
print(f"Offspring 2: {offspring2}")</pre>
</body>
</html>
