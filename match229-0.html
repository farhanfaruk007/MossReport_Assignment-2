<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/21101216_md_tasnim_muttaki_sec_10_lab_2_-_MD.TASNIM_MUTTAKI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/21101216_md_tasnim_muttaki_sec_10_lab_2_-_MD.TASNIM_MUTTAKI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Md.Tasnim_Muttaki_21101216_sec-10_lab-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1abh-1j9o2Iytq43jiTDf-Ir3W6Cgucrv
<a name="1"></a><font color="#00FF00"><a href="match229-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

"""

import random

def initialize_population(course_num, t_slots, p_sz):
    cr_sm_length = course_num * t_slots
    return [''.join(random.choice('01') for _ in range(cr_sm_length)) for _ in range(p_sz)]

def calculate_fitness(cr_sm, course_num, t_slots):
    over_pen = 0
    cons_pen = 0
    timeslots = [cr_sm[i * course_num:(i + 1) * course_num] for i in range(t_slots)]
</font>    for slot in timeslots:
        count = sum(int(c) for c in slot)
        if count &gt; 1:
            over_pen += count - 1
    for course_idx in range(course_num):
        count = sum(int(slot[course_idx]) for slot in timeslots)
        if count != 1:
            cons_pen += abs(count - 1)
    total_penalty = over_pen + cons_pen
    return -total_penalty

def select_parents(population, fitnesses):
    return random.choices(population, weights=fitnesses, k=2)

def single_point_crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    offspring_1 = parent1[:point] + parent2[point:]
<a name="0"></a><font color="#FF0000"><a href="match229-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

    offspring_2 = parent2[:point] + parent1[point:]
    return  offspring_1,  offspring_2

def mutate(cr_sm, mutation_rate=0.01):
    return ''.join(c if random.random() &gt; mutation_rate else str(1 - int(c)) for c in cr_sm)

def genetic_algorithm(course_num, t_slots, p_sz, max_gen):
    population = initialize_population(course_num, t_slots, p_sz)
    for generation in range(max_gen):
        fitnesses = [calculate_fitness(chromo, course_num, t_slots) for chromo in population]
</font>        if max(fitnesses) == 0:
            break
        new_population = []
        for _ in range(p_sz // 2):
            parent1, parent2 = select_parents(population, fitnesses)
             offspring_1,  offspring_2 = single_point_crossover(parent1, parent2)
            new_population.extend([mutate( offspring_1), mutate( offspring_2)])
        population = new_population
    best_solution = max(population, key=lambda chromo: calculate_fitness(chromo, course_num, t_slots))
    best_fitness = calculate_fitness(best_solution, course_num, t_slots)
    return best_solution, best_fitness

def two_point_crossover(parent1, parent2):
    point1 = random.randint(0, len(parent1) - 2)
    point2 = random.randint(point1 + 1, len(parent1) - 1)
     offspring_1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
     offspring_2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]
    return  offspring_1,  offspring_2

def main():
    with open("input.txt", "r") as infile:
        lines = infile.readlines()
        N, T = map(int, lines[0].split())
        courses = [line.strip() for line in lines[1:N+1]]

    solution, fitness = genetic_algorithm(N, T, p_sz=50, max_gen=100)

    parent1 = '000111000'
    parent2 = '111000111'
    offspring_1,  offspring_2 = two_point_crossover(parent1, parent2)

    with open("output.txt", "w") as outfile:
        outfile.write(f"{solution}\n")
        outfile.write(f"{fitness}\n")
        outfile.write(f"{ offspring_1}\n")
        outfile.write(f"{ offspring_2}\n")

</pre>
</body>
</html>
