<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/22101239_nishat_tasnim_cse422_03_lab_assignment02_fall2024_-_NISHAT_TASNIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/22101239_nishat_tasnim_cse422_03_lab_assignment02_fall2024_-_NISHAT_TASNIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101239_Nishat_Tasnim_CSE422_03_Lab Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14_8qFQVs-DFAkdtl5kgEYyZp604Ou_02
"""

import random


input_file = open("input.txt", "r")
course_count, timeslot_count = map(int, input_file.readline().split())
course_data = [input_file.readline().strip() for index in range(course_count)]
input_file.close()


def evaluate_timetable(timetable, course_count, timeslot_count):
    overlap_penalty = 0
    scheduling_penalty = 0


    for slot_index in range(timeslot_count):
        slot_courses = timetable[slot_index * course_count:(slot_index + 1) * course_count]
        active_courses = slot_courses.count('1')
<a name="0"></a><font color="#FF0000"><a href="match217-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

        if active_courses &gt; 1:
            overlap_penalty += active_courses - 1


    for course_index in range(course_count):
        course_schedule_count = 0
        for slot_index in range(timeslot_count):
            if timetable[slot_index * course_count + course_index] == '1':
                course_schedule_count += 1
        if course_schedule_count != 1:
            scheduling_penalty += abs(course_schedule_count - 1)
</font>
    return -(overlap_penalty + scheduling_penalty)


def generate_timetable(course_count, timeslot_count):
    return ''.join(random.choice('01') for i in range(course_count * timeslot_count))


def choose_parents(population_pool):
    return random.sample(population_pool, 2)


def reproduce(parent_a, parent_b):
    split_index = random.randint(1, len(parent_a) - 1)
    offspring_a = parent_a[:split_index] + parent_b[split_index:]
    offspring_b = parent_b[:split_index] + parent_a[split_index:]
    return offspring_a, offspring_b

def apply_mutation(timetable, mutation_probability=0.01):
    mutated = []
    for gene in timetable:
        if random.random() &lt; mutation_probability:
            mutated.append('1' if gene == '0' else '0')
        else:
            mutated.append(gene)
    return ''.join(mutated)


def initialize_population(pop_size, course_count, timeslot_count):
    return [generate_timetable(course_count, timeslot_count) for i in range(pop_size)]


<a name="2"></a><font color="#0000FF"><a href="match217-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

def optimize_schedule(course_count, timeslot_count, population_size=50, max_generations=500, mutation_probability=0.01):
    population = initialize_population(population_size, course_count, timeslot_count)
    best_timetable = None
    highest_fitness = float('-inf')

    for generation in range(max_generations):

        population.sort(key=lambda individual: evaluate_timetable(individual, course_count, timeslot_count), reverse=True)
</font>

        current_best = evaluate_timetable(population[0], course_count, timeslot_count)
        if current_best &gt; highest_fitness:
            best_timetable = population[0]
            highest_fitness = current_best

        if highest_fitness == 0:
            break


<a name="1"></a><font color="#00FF00"><a href="match217-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

        next_gen = population[:population_size // 2]
        while len(next_gen) &lt; population_size:
            parent_one, parent_two = choose_parents(population)
            child_one, child_two = reproduce(parent_one, parent_two)
            next_gen.append(apply_mutation(child_one, mutation_probability))
            next_gen.append(apply_mutation(child_two, mutation_probability))

        population = next_gen

    return best_timetable, highest_fitness


res_timetable, res_fitness = optimize_schedule(course_count, timeslot_count)
</font>print(res_timetable)
print(res_fitness)</pre>
</body>
</html>
