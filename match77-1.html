<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/3/21301619_inzamul_kabir_tanvir_cse422_03_lab_assignment02_fall2024_-_INZAMUL_KABIR_TANVIR.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/12/24341058_arjun_cse422_lab12_ass02_-_ARJUN_SAHA(1).py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341058_Arjun_CSE422_Lab12_Ass02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-RmtCFqKUvyHpxwaoeP9fGGlwL4pIHEg
"""

import math
import random
def overlap_penalty(time_slots,N,T):
    cheack_arr=[]
    overlap_P=0
    for i in range(T):
        indivisual_slot=time_slots[i*N:(i+1)*N]
        # print(indivisual_slot)
        count=max(indivisual_slot.count("1")-1,0)
        overlap_P+=count
    return overlap_P
def consistency_panelty(time_slots,N,T):
    panelty=0

    for i in range(N):
        panelty_count = 0
        for j in range(T):
            panelty_count+=int(time_slots[j*N+i])
            # print(panelty_count)
            # panelty-=1

        panelty+=abs(panelty_count-1)
        # print(panelty)
    return panelty

def calculate_fitness(time_slots,N,T):
    panelty= -(overlap_penalty(time_slots,N,T)+consistency_panelty(time_slots,N,T))
    return panelty
def create_population(n,t,population_size):
    population_list=[]

    for j in range(population_size):
        population = ""
        for i in range(n*t):
            population+=random.choice('01')
        # print(population)
        population_list.append(population)
    return population_list
def parents_selection(population):
    return random.choice(population),random.choice(population)
def crossover(parent1,parent2,N,T):
    point=random.randint(0,N*T-1)
    child1=parent1[0:point]+parent2[point:]
    child2=parent2[0:point]+parent1[point:]
    return child1,child2
def mutation(child,N,T):
    point=random.randint(1,N*T-1)
    list1=list(child)
    # print(list1)
    if list1[point]=="1":
        list1[point]="0"
    else:
        list1[point]="1"
    return "".join(list1)

def genetic_algo(N,T,population_size,iterations):
    population=create_population(N,T,population_size)
    # print(population)
    lowest_fitness=-math.inf
    best_slot=None
    for _ in range(iterations):
        new_population=[]
        for _ in range(population_size//2):
            parent1,parent2=parents_selection(population)
            child1,child2=crossover(parent1,parent2,N,T)
            new_population.extend([mutation(child1,N,T),mutation(child2,N,T)])
        population=new_population
        for slots in population:
            fitess_value=calculate_fitness(slots,N,T)

            if fitess_value&gt;lowest_fitness:
                lowest_fitness = fitess_value
                best_slot = slots

            if lowest_fitness==0:
                break
    return lowest_fitness,best_slot


N,T=int(input("Enter Num_of_Courses: ")),int(input("Enter TimeSlots:"))
courses=[input("Enter courses: ") for i in range(N)]
if T&lt;N:
    print("TimeSlots can't be less than Num_of_Courses")
else:
    fitness,schedule=genetic_algo(N,T,population_size=100,iterations=1000)
    print(schedule)
    print(fitness)

import random
<a name="1"></a><font color="#00FF00"><a href="match77-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_16.gif"/></a>

import math

input_file = open("input.txt")
output_file = open("Output_1.txt", "w")

input_data = input_file.readlines()
time_class_lengths = input_data[0].strip().split(' ')
time_length = int(time_class_lengths[0])
class_length = int(time_class_lengths[1])

population = {}
if class_length &lt;= time_length:
    for i in range(0, 150):
        chromosome = ''
        for j in range(0, time_length * class_length):
            chromosome += str(random.randint(0, 1))
        population[chromosome] = 0

def overlap_penalty(sequence):
    penalty_score = 0
    for i in range(0, int(len(sequence) / time_length)):
        overlap_flag = 0
        for j in range(i, len(sequence), 3):
            if sequence[j] == '1':
                overlap_flag += 1
        if overlap_flag &gt; 0:
            penalty_score += (overlap_flag - 1)
    return penalty_score

def consistency_penalty(sequence):
    penalty_score = 0
    for i in range(0, len(sequence), 3):
</font>        consistency_flag = 0
        for j in range(i, i + 3):
<a name="2"></a><font color="#0000FF"><a href="match77-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

            if sequence[j] == '1':
                consistency_flag += 1
        if consistency_flag &gt; 0:
            penalty_score += (consistency_flag - 1)
    return penalty_score

fitness_values = []
def calculate_fitness(sequence):
    fitness_penalty = -(overlap_penalty(sequence) + consistency_penalty(sequence))
    fitness_values.append((sequence, fitness_penalty))
    return fitness_penalty

def perform_crossover(parent_1, parent_2):
    midpoint = int(len(parent_1) / 2)
</font>    offspring_1 = parent_1[:midpoint] + parent_2[midpoint:]
    offspring_2 = parent_1[midpoint:] + parent_2[:midpoint]
<a name="0"></a><font color="#FF0000"><a href="match77-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_20.gif"/></a>

    population[offspring_1] = 0
    population[offspring_2] = 0
    return offspring_1, offspring_2

def apply_mutation(sequence):
    sequence_list = list(sequence)

    mutation_point = random.randint(0, len(sequence_list) - 1)

    sequence_list[mutation_point] = str(1 - int(sequence_list[mutation_point]))

    mutated_sequence = ''.join(sequence_list)

    return mutated_sequence


def genetic_algorithm_iteration(parent_1, parent_2, limit):
    child_x, child_y = perform_crossover(parent_1, parent_2)
    if calculate_fitness(child_x) == 0:
        return child_x
    elif calculate_fitness(child_y) == 0:
        return child_y
    else:
        limit -= 1
        if limit == 0:
            return "000000000"
        child_x = apply_mutation(child_x)
        child_y = apply_mutation(child_y)
        return genetic_algorithm_iteration(child_x, child_y, limit)

random_x = list(population.keys())[random.randint(0, len(population) - 1)]
random_y = list(population.keys())[random.randint(0, len(population) - 1)]
final_result = genetic_algorithm_iteration(random_x, random_y, 1000)

if final_result in ["000000000", "111111111"]:
    print('-100', file=output_file)
else:
    print(final_result, file=output_file)
    for seq, fit in fitness_values:
        if seq == final_result:
            print(fit, file=output_file)

input_file.close()
</font>output_file.close()</pre>
</body>
</html>
