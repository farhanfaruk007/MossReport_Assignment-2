<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/4/21301456_fatema_tuz_zohora_panna_cse422_04_assignment02_fall2024_py_-_FATEMA_TUZ_ZOHORA_PANNA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/11/24141242_simran_zaman_mayabi_cse422_11_lab_assignment2_fall2024_-_SIMRAN_ZAMAN_MAYABI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141242_Simran Zaman Mayabi_CSE422_11_Lab_Assignment2_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wYAeZhxfgx60CJtr0wj-ztXOLGBpcnso

inp.txt
3 3
CSE110
MAT110
PHY112
"""

import random
import numpy as np

def calculate_fitness(chromosome, N, T):
    overlap_penalty = 0
    consistency_penalty = 0

    schedule = np.array([list(map(int, chromosome[i * N:(i + 1) * N])) for i in range(T)])


    for timeslot in schedule:
        overlap_penalty += max(0, sum(timeslot) - 1)  # Penalty


    course_scheduled = np.sum(schedule, axis=0)  # Sum
    for course_count in course_scheduled:
        consistency_penalty += abs(course_count - 1)  # Penalize

    return -(overlap_penalty + consistency_penalty)


def single_point_crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)  #  crossover point
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2


def mutate(chromosome, mutation_rate):
    mutated = list(chromosome)
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
            mutated[i] = '1' if chromosome[i] == '0' else '0'
    return ''.join(mutated)

def generate_population(pop_size, chromosome_length):
    return ["".join(random.choice("01") for _ in range(chromosome_length)) for _ in range(pop_size)]

def genetic_algorithm(N, T, max_generations, pop_size, mutation_rate):
    chromosome_length = N * T
    population = generate_population(pop_size, chromosome_length)
    best_solution = None
    best_fitness = float('-inf')

    for generation in range(max_generations):
        fitness_scores = [calculate_fitness(chromo, N, T) for chromo in population]


        max_fitness_idx = np.argmax(fitness_scores)
        if fitness_scores[max_fitness_idx] &gt; best_fitness:
            best_fitness = fitness_scores[max_fitness_idx]
            best_solution = population[max_fitness_idx]


        fitness_probs = [score - min(fitness_scores) + 1 for score in fitness_scores]
        parents = random.choices(population, weights=fitness_probs, k=pop_size)


        next_generation = []
        for i in range(0, pop_size, 2):
            parent1, parent2 = parents[i], parents[(i + 1) % pop_size]
            offspring1, offspring2 = single_point_crossover(parent1, parent2)
            next_generation.extend([offspring1, offspring2])

        # Mutation
        population = [mutate(chromo, mutation_rate) for chromo in next_generation]

    return best_solution, best_fitness


try:
    from google.colab import files
    uploaded = files.upload()

    for file_name in uploaded.keys():
        with open(file_name, 'r') as f:
            lines = f.readlines()


        N, T = map(int, lines[0].split())
        courses = [line.strip() for line in lines[1:]]


        if T &lt; N:
            print("Error: Number of timeslots must be greater than or equal to the number of courses.")
            break


        max_generations = 1000
        pop_size = 50
        mutation_rate = 0.01


        best_chromosome, best_fitness = genetic_algorithm(N, T, max_generations, pop_size, mutation_rate)


        print(f"Best Chromosome: {best_chromosome}")
        print(f"Fitness Value: {best_fitness}")

except Exception as e:
    print("Error:", e)

#part2
import random


given_population = [

    "111000111",
    "000111000",
]

def two_point_crossover(first_parent, second_parent):
    length = len(first_parent)


    crossover_1 = 2
    crossover_2 = 6

    child_a = first_parent[:crossover_1] + second_parent[crossover_1:crossover_2] + first_parent[crossover_2:]
    child_b = second_parent[:crossover_1] + first_parent[crossover_1:crossover_2] + second_parent[crossover_2:]

    return child_a, child_b, crossover_1, crossover_2


first_parent, second_parent = random.sample(given_population, 2)


child_a, child_b, crossover_1, crossover_2 = two_point_crossover(first_parent, second_parent)

print(f"Parent 1:  {first_parent}")
print(f"Parent 2:  {second_parent}")

print(f"1st point: between index {crossover_1} and index {crossover_1 + 1}")
print(f"2nd point: between index {crossover_2} and index {crossover_2 + 1}")
print(f"Child 1:   {child_a}")
print(f"Child 2:   {child_b}")

import random
from google.colab import files


def read_input(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    N, T = map(int, lines[0].strip().split())
    courses = [line.strip() for line in lines[1:N+1]]
    return N, T, courses


<a name="0"></a><font color="#FF0000"><a href="match235-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

def initialize_population(pop_size, N, T):
    population = []
    for _ in range(pop_size):
        chromosome = ['0'] * (N * T)
        for i in range(N):
            timeslot = random.randint(0, T - 1)
            chromosome[timeslot * N + i] = '1'
        population.append(''.join(chromosome))
    return population


def calculate_fitness(chromosome, N, T):
    overlap_penalty = 0
    consistency_penalty = 0


    for t in range(T):
        segment = chromosome[t * N:(t + 1) * N]
</font>        count = segment.count('1')
        if count &gt; 1:
            overlap_penalty += count - 1


    for i in range(N):
        course_count = sum(1 for t in range(T) if chromosome[t * N + i] == '1')
        if course_count != 1:
            consistency_penalty += abs(course_count - 1)

    total_penalty = overlap_penalty + consistency_penalty
    fitness = -total_penalty
    return fitness


def select_parents(population, fitnesses):
    total_fitness = sum(fitnesses)
    if total_fitness == 0:
        probabilities = [1 / len(fitnesses)] * len(fitnesses)
    else:
        probabilities = [f / total_fitness for f in fitnesses]
    parents = random.choices(population, probabilities, k=2)
    return parents


def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]
    return offspring1, offspring2


def mutate(chromosome, mutation_rate=0.01):
    mutated = ''.join(
        bit if random.random() &gt; mutation_rate else '1' if bit == '0' else '0'
        for bit in chromosome
    )
    return mutated


def two_point_crossover(parent1, parent2):
    length = len(parent1)
    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)

    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2


def tournament_selection(population, fitnesses, tournament_size=3):
    selected = random.sample(list(zip(population, fitnesses)), tournament_size)
    selected.sort(key=lambda x: x[1], reverse=True)
    return selected[0][0]

<a name="1"></a><font color="#00FF00"><a href="match235-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

def genetic_algorithm(N, T, courses, pop_size=100, max_generations=1000, mutation_rate=0.01):
    population = initialize_population(pop_size, N, T)
    best_fitness = float('-inf')
    best_chromosome = None

    for generation in range(max_generations):
        fitnesses = [calculate_fitness(chromosome, N, T) for chromosome in population]

        for i, fitness in enumerate(fitnesses):
</font>            if fitness &gt; best_fitness:
                best_fitness = fitness
                best_chromosome = population[i]

        new_population = []
        while len(new_population) &lt; pop_size:
            parent1, parent2 = select_parents(population, fitnesses)
            offspring1, offspring2 = crossover(parent1, parent2)
            offspring1 = mutate(offspring1, mutation_rate)
            offspring2 = mutate(offspring2, mutation_rate)
            new_population.extend([offspring1, offspring2])

        population = new_population


        if best_fitness == 0:
            break

    return best_chromosome, best_fitness


def main():
    print("Please upload the input file (e.g., input.txt):")
    uploaded = files.upload()

    for file_name in uploaded.keys():
        N, T, courses = read_input(file_name)
        best_chromosome, best_fitness = genetic_algorithm(N, T, courses)
        print("\nBest Chromosome:", best_chromosome)
        print("Best Fitness:", best_fitness)


        population = initialize_population(10, N, T)
        parent1, parent2 = select_parents(population, [calculate_fitness(c, N, T) for c in population])
        offspring1, offspring2 = two_point_crossover(parent1, parent2)
        print("\nTwo-Point Crossover:")
        print("Parent 1:", parent1)
        print("Parent 2:", parent2)
        print("Offspring 1:", offspring1)
        print("Offspring 2:", offspring2)


        fitnesses = [calculate_fitness(chromosome, N, T) for chromosome in population]
        parent1 = tournament_selection(population, fitnesses)
        parent2 = tournament_selection(population, fitnesses)
        print("\nTournament Selection:")
        print("Parent 1 (Tournament Selection):", parent1)
        print("Parent 2 (Tournament Selection):", parent2)


main()</pre>
</body>
</html>
