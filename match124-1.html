<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/9/24141279_MD._SAIFUL_ISLAM_DIPU_24141279_-_MD._SAIFUL_ISLAM_DIPU.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/10/23141030_cse422_10_labassignment2_-_SYED_TASRIF_HASAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""23141030_CSE422_10_LabAssignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qDc3lDyb8wJl-ZfahGPJtknhRnUK-5WU

Syed Tasrif Hasan
ID:23141030
Sec:10
"""

#part1
import random

<a name="2"></a><font color="#0000FF"><a href="match124-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

class schedule:
    def __init__(self, n, t, total_chromo, max_depth, mutation_rate=0.1):
        self.n = n
        self.t = t
        self.total_chromo = total_chromo
        self.max_depth = max_depth
        self.mutation_rate = mutation_rate #10%
        self.chromoList = self.chromosome_generate()

    def chromosome_generate(self):
</font>        chromoList = []
        for i in range(self.total_chromo):
            chromosome = [random.randint(0, 1) for c in range(self.n * self.t)]
            chromoList.append(chromosome)

        #print(population)
        return chromoList

    def genetic_algorithm(self):
        generation_depth = 0
        best_fit = float('-inf')
        best_list = None

        while generation_depth &lt; self.max_depth:
            fitness_list = [self.fitness(chromosome) for chromosome in self.chromoList]
            #print(fitness_list)
            max_fit = max(fitness_list)
            if max_fit &gt; best_fit:
                best_fit = max_fit
<a name="3"></a><font color="#00FFFF"><a href="match124-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

                best_list = self.chromoList[fitness_list.index(max_fit)]

            new_chromosomeList = []

            for i in range(self.total_chromo // 2):
                parent1, parent2 = self.select_parents(fitness_list)
                offspring1, offspring2 = self.crossover(parent1, parent2)
                child1 = self.mutate(offspring1)
</font>                child2 = self.mutate(offspring2)
                new_chromosomeList.extend([child1, child2])

            self.chromoList = new_chromosomeList
            generation_depth += 1

        return best_list, best_fit

<a name="0"></a><font color="#FF0000"><a href="match124-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

    def fitness(self, chromosome):
        overlap_penalty = 0
        consistency_penalty = 0

        # overlap penalty
        for t in range(self.t):
            same_slot = sum(chromosome[t * self.n:(t + 1) * self.n])
            if same_slot &gt; 1:
                overlap_penalty += (same_slot - 1)
        # consistency penalty
        for n in range(self.n):
            repeat_course = sum(chromosome[n::self.n])
            consistency_penalty += abs(repeat_course - 1)

        return  -(overlap_penalty + consistency_penalty)

    def select_parents(self, fitness_list):
        total_fitness = sum(fitness_list)
        fitness_probs = [fitness / total_fitness for fitness in fitness_list]
</font>        parent1 = random.choices(self.chromoList, weights=fitness_probs)[0]
        parent2 = random.choices(self.chromoList, weights=fitness_probs)[0]
        return parent1, parent2

    def crossover(self, parent1, parent2):
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = parent1[:crossover_point] + parent2[crossover_point:]
        child2 = parent2[:crossover_point] + parent1[crossover_point:]
        return child1, child2

    def mutate(self, chromosome):
        for i in range(len(chromosome)):
            if random.random() &lt; self.mutation_rate:
                chromosome[i] = 1 - chromosome[i] #if 1, then 0. if 0  then 1.
<a name="4"></a><font color="#FF00FF"><a href="match124-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

        return chromosome

with open("input.txt", 'r') as f1:
    first_line = f1.readline().strip()
    number_of_courses, number_of_timeslots = map(int, first_line.split())

    if number_of_timeslots &lt; number_of_courses:
        raise ValueError("Number of timeslots T should be greater than or equal to the number of courses N")

    courses = []
</font>    for i in range(number_of_courses):
        courses.append(f1.readline().strip())

<a name="1"></a><font color="#00FF00"><a href="match124-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

total_chromo = 20
max_depth = 1000

optimized_schedule = schedule(number_of_courses, number_of_timeslots, total_chromo, max_depth)
s, f = optimized_schedule.genetic_algorithm()

print("Best Solution:", ''.join(map(str, s)))
print("Fitness:", f)

with open("output.txt", "w") as f2:
    f2.write("Best Solution: " + ''.join(map(str, s)) + "\n")
    f2.write("Fitness: " + str(f) + "\n")
</font>
#part2
def two_point_crossover(self):
    parent1 = random.choice(self.chromoList)
    parent2 = random.choice(self.chromoList)

    print("Parent1: ",''.join(map(str,parent1)))
    print("Parent2: ", ''.join(map(str,parent2)))

    crossover_point1 = random.randint(1, len(parent1) - 2)
    crossover_point2 = random.randint(crossover_point1 + 1, len(parent1) - 1)
    print(crossover_point1, crossover_point2)

    child1 = parent1[:crossover_point1] + parent2[crossover_point1:crossover_point2] + parent1[crossover_point2:]
    child2 = parent2[:crossover_point1] + parent1[crossover_point1:crossover_point2] + parent2[crossover_point2:]

    print("Child1 : ",''.join(map(str,child1)))
    print("Child2 : ",''.join(map(str,child1)))

two_point_crossover(optimized_schedule)</pre>
</body>
</html>
