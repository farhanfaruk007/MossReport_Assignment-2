<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/7/22101802_AhnafWarid_CSE422_07_Assignment02_Fall2024_-_AHNAF_WARID.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/18/23301382_md_mehedi_hasan_cse422_18_assignment02_fall2024_py_-_MD.MEHEDI_HASAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""23301382_MD.MEHEDI HASAN_CSE422_18_Assignment02_Fall2024.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tty8NOwodoh9WcZW0Zk-9D-RZVKA6PIp
"""

#TASK1
import random

# Fitness function
def fitness(chromosome, N, T):
    penalties_overlap = 0
    penalties_consistency = 0

    # Overlap penalty: Check each timeslot
    for t in range(T):
        timeslot = chromosome[t * N:(t + 1) * N]
        courses_in_timeslot = sum(timeslot)  # Count how many courses are in this timeslot
        if courses_in_timeslot &gt; 1:  # Penalize overlaps
            penalties_overlap += courses_in_timeslot - 1

    # Consistency penalty: Check each course
    for n in range(N):
        course_count = sum(chromosome[t * N + n] for t in range(T))  # Count how many times course n is scheduled
        if course_count != 1:  # Penalize missing or extra appearances
<a name="0"></a><font color="#FF0000"><a href="match218-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

            penalties_consistency += abs(course_count - 1)

    # Total penalty
    total_penalty = penalties_overlap + penalties_consistency
    return -total_penalty  # Return negative of penalty to get fitness

# Generate random chromosome ensuring each course is scheduled exactly once
def generate_chromosome(N, T):
    chromosome = [0] * (N * T)
    # Assign each course to one of the time slots
    for n in range(N):
        # Randomly select a time slot for each course
        timeslot = random.randint(0, T - 1)
        chromosome[timeslot * N + n] = 1
    return chromosome

# Crossover function
def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 2)  # Single-point crossover
    child1 = parent1[:point] + parent2[point:]
</font>    child2 = parent2[:point] + parent1[point:]
    return child1, child2

# Mutation function
def mutate(chromosome, mutation_rate, N, T):
    for i in range(len(chromosome)):
        if random.random() &lt; mutation_rate:
            # Flip the bit
            chromosome[i] = 1 - chromosome[i]

    # Ensure every course is scheduled exactly once
    for n in range(N):
        # Count how many times each course is scheduled
        course_count = sum(chromosome[t * N + n] for t in range(T))
        if course_count == 0:
            # If course is not scheduled, place it randomly in one of the time slots
            timeslot = random.randint(0, T - 1)
            chromosome[timeslot * N + n] = 1
        elif course_count &gt; 1:
            # If course is scheduled more than once, remove one occurrence randomly
            indices = [t * N + n for t in range(T) if chromosome[t * N + n] == 1]
            while len(indices) &gt; 1:
                idx_to_remove = random.choice(indices)
                chromosome[idx_to_remove] = 0
                indices.remove(idx_to_remove)

    return chromosome

# Genetic Algorithm
def genetic_algorithm(N, T, max_generations=1000, population_size=20, mutation_rate=0.01):
    # Initialize population
    population = [generate_chromosome(N, T) for _ in range(population_size)]

    best_fitness = float('-inf')
    best_chromosome = None

    for generation in range(max_generations):
        # Evaluate fitness
<a name="1"></a><font color="#00FF00"><a href="match218-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

        population_fitness = [(chromosome, fitness(chromosome, N, T)) for chromosome in population]
        population_fitness.sort(key=lambda x: x[1], reverse=True)

        # Update the best chromosome
        if population_fitness[0][1] &gt; best_fitness:
            best_fitness = population_fitness[0][1]
            best_chromosome = population_fitness[0][0]

        # Selection (top 50%)
        parents = [chromosome for chromosome, _ in population_fitness[:population_size // 2]]
</font>
        # Crossover to produce offspring
        offspring = []
        for _ in range(population_size // 2):
            p1, p2 = random.sample(parents, 2)
            child1, child2 = crossover(p1, p2)
            offspring.extend([child1, child2])

        # Mutation
        population = [mutate(chromosome, mutation_rate, N, T) for chromosome in offspring]

        # Ensure no chromosome is all zeros
        population = [chrom if any(chrom) else generate_chromosome(N, T) for chrom in population]

    return best_chromosome, best_fitness

# Input
N, T = map(int, input().split())
courses = [input().strip() for _ in range(N)]

# Run Genetic Algorithm
if T &lt; N:
    print("Invalid input: T must be greater than or equal to N.")
else:
    result, fitness_value = genetic_algorithm(N, T)
    print("".join(map(str, result)))
    print(fitness_value)

#TASK 2
import random

def two_point_crossover(parent1, parent2):
    # Ensure that both parents are of the same length
    length = len(parent1)

    # Randomly select two crossover points
    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)

    # Crossover operation: swap the segments between the two points
    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    return offspring1, offspring2

# Example parents
parent1 = "000111000"
parent2 = "111000111"

# Perform crossover
offspring1, offspring2 = two_point_crossover(parent1, parent2)

# Print the offspring
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)

</pre>
</body>
</html>
