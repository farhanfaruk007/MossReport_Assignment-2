<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/16/24141162_cse422_16_labassignment2_-_MD._ABRAR_AHSAN_PURNO.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/16/24141162_cse422_16_labassignment2_-_MD._ABRAR_AHSAN_PURNO.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141162_CSE422_16_LabAssignment2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uTZBYSYk8ZIJ18N2qTenTPpKIZN1b5zg

## PART **A**
"""

import random

'''Input text
   3 3
   CSE110
   MAT110
   PHY112   '''


with open("/content/input_CSE422_lab03.txt", 'r') as file:
    lines = file.readlines()
num_courses, num_timeslots = map(int, lines[0].split())
course_codes = [i.strip() for i in lines[1:]]



<a name="2"></a><font color="#0000FF"><a href="match214-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

def fitness(chromosome, num_courses, num_timeslots):
    timeslots = []
    for i in range(num_timeslots):
        timeslots.append(chromosome[i * num_courses:(i + 1) * num_courses])
</font>
    overlap_penalty = 0
    consistency_penalty = 0
    course_count = [0] * num_courses

<a name="0"></a><font color="#FF0000"><a href="match214-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

    for slot in timeslots:
        courses_in_slot = sum(slot)
        if courses_in_slot &gt; 1:
            overlap_penalty += courses_in_slot - 1
        for i, is_scheduled in enumerate(slot):
            if is_scheduled:
                course_count[i] += 1

    for count in course_count:
        if count != 1:
            consistency_penalty += abs(count - 1)

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty

def create_population(num_courses, num_timeslots, population_size=10):
    chromosome_length = num_courses * num_timeslots
</font>    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(population_size)]

def select_parents(population):
    return random.sample(population, 2)

def single_point_crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    return offspring1, offspring2

def mutate(chromosome, mutation_rate=0.01):
    return [gene if random.random() &gt; mutation_rate else 1 - gene for gene in chromosome]

def genetic_algorithm(num_courses, num_timeslots, max_generations=100):
    population = create_population(num_courses, num_timeslots)
    best_fitness = float('-inf')
    best_chromosome = None

    for _ in range(max_generations):
        fitness_scores = [fitness(ch, num_courses, num_timeslots) for ch in population]

<a name="1"></a><font color="#00FF00"><a href="match214-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        for i, score in enumerate(fitness_scores):
            if score &gt; best_fitness:
                best_fitness = score
                best_chromosome = population[i]

        new_population = []
        while len(new_population) &lt; len(population):
            parent1, parent2 = select_parents(population)
</font>            offspring1, offspring2 = single_point_crossover(parent1, parent2)
            new_population.extend([mutate(offspring1), mutate(offspring2)])

        population = new_population

    return best_chromosome, best_fitness

optimal_chromosome, optimal_fitness = genetic_algorithm(num_courses, num_timeslots)
print("Chromosome:", ''.join(map(str, optimal_chromosome)))
print("Fitness:", optimal_fitness)

"""## PART **B**"""

parent1 = "001001001"
parent2 = "100100100"

def two_point_crossover(parent1,parent2):
    length = len(parent1)

    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)

    offspring1 = ( parent1[:point1] + parent2[point1:point2] + parent1[point2:])
    offspring2 = (parent2[:point1] + parent1[point1:point2] + parent2[point2:])

    return offspring1, offspring2, (point1, point2)

offspring1, offspring2, points = two_point_crossover(parent1, parent2)


print(f"Parent 1: {parent1}")
print(f"Parent 2: {parent2}")
print(f"Crossover Points: {points}")
print(f"Offspring 1: {offspring1}")
print(f"Offspring 2: {offspring2}")

</pre>
</body>
</html>
