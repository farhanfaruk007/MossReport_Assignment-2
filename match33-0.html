<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/21101045_sabrina_sultana_cse422_06_assignment02_fall2024_-_SABRINA_SULTANA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/6/21101045_sabrina_sultana_cse422_06_assignment02_fall2024_-_SABRINA_SULTANA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101045_Sabrina Sultana_CSE422_06_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SEQX3YP53ta9HDZ3du9w8vk-Pf7-AEif
"""

from heapq import *
from random import randint, shuffle, sample

def read_input():
    f = open("/content/lab2input.txt", 'r')
    lines = f.readlines()
    f.close()
    temp = lines[0].split(" ")
    N = temp[0]
    T = temp[1]
    return int(N), int(T)

<a name="0"></a><font color="#FF0000"><a href="match33-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_20.gif"/></a>

def overlap_penalty(chr, N):
    L = len(chr)
    errors = 0
    initial_string = 0
    for i in range(N, L + 1, N):
        count = 0
        temp_string = chr[initial_string:i]
        for j in temp_string:
            if j == "1":
                count += 1
        if count == 1:
            count = 0
        elif count &gt; 1:
            count -= 1
        errors += count
        initial_string += N
    return errors

def consistency_penalty(chr, T):
    L = len(chr)
    course_dict = {}
    for key in range(T):
        course_dict[key] = 0
    initial_string = 0
    for i in range(T, L + 1, T):
        temp_string = chr[initial_string:i]
        for key in course_dict:
            if temp_string[key] == "1":
                course_dict[key] += 1
        initial_string += T
    errors = 0
    for key in course_dict:
        errors += abs(course_dict[key] - 1)
</font>    return errors

<a name="2"></a><font color="#0000FF"><a href="match33-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_12.gif"/></a>

def fitness_function(chr, N, T):
    return -1 * (overlap_penalty(chr, N) + consistency_penalty(chr, T))

def mutation_function(chr):
    L = len(chr)
    index = randint(0, L - 1)
    replace_with = randint(0, 1)
    new_string = chr[:index] + str(replace_with) + chr[index + 1:]
    return new_string

def single_p_crossover(chrA, chrB):
    L = len(chrA)
    last_idx = L - 1
    divider = randint(1, last_idx - 1)
    new_chrA = chrA[:divider] + chrB[divider:]
    new_chrB = chrB[:divider] + chrA[divider:]
</font>    return new_chrA, new_chrB

<a name="4"></a><font color="#FF00FF"><a href="match33-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

def two_p_crossover(chromosomeA, chromosomeB):
    L = len(chromosomeA)
    last_idx = L - 1
    first_cut = randint(1, last_idx - 2)
    second_cut = randint(first_cut + 1, last_idx - 1)
    new_chrA = chromosomeA[:first_cut] + chromosomeB[first_cut:second_cut] + chromosomeA[second_cut:]
</font>    new_chrB = chromosomeB[:first_cut] + chromosomeA[first_cut:second_cut] + chromosomeB[second_cut:]
    print("\nFor two-point crossover, we have randomly chosen the following points:")
    print(f"1st point: between index {first_cut} and index {first_cut + 1}")
    print(f"2nd point: between index {second_cut} and index {second_cut + 1}")
<a name="1"></a><font color="#00FF00"><a href="match33-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

    return new_chrA, new_chrB

def population_generator(L, size):
    temp_arr = []
    for i in range(size):
        temp_chr = ""
        for j in range(L):
            temp_chr += str(randint(0, 1))
        temp_arr.append(temp_chr)
    return temp_arr

def helper_function(population, N, T):
    tempList = population[:]
    finalList = population[:]
    shuffle(tempList)
    children = []
    for i in range(0, 10, 2):
        childA, childB = single_p_crossover(tempList[i], tempList[i + 1])
        childA, childB = mutation_function(tempList[i]), mutation_function(tempList[i + 1])
        children += [childA, childB]
    labRat = finalList + children
    queue = []
    for i in labRat:
        heappush(queue, [fitness_function(i, N, T), i])
    return queue

def genetic_algorithm_function(N, T):
    fitness = -100
    population = population_generator(N * T, 10)
</font><a name="3"></a><font color="#00FFFF"><a href="match33-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_8.gif"/></a>

    iter_ = 0
    while fitness != 0:
        queue = helper_function(population, N, T)
        fitness = nlargest(1, queue)[0][0]
        new_population_list = []
        temp_p = nlargest(10, queue)
        for i in temp_p:
            if i[1] not in new_population_list:
                new_population_list.append(i[1])
        population += new_population_list
        iter_ += 1
        if iter_ &gt; 10000000:
</font>            break
    final_population_list = nlargest(10, queue)
    print("Final population and their respective fitnesses:")
    print([[i[1], i[0]] for i in final_population_list])
    print("\nTotal iterations:", iter_)
    print("One solutions is", final_population_list[0][1],"\nwith fitness", final_population_list[0][0])
    return [i[1] for i in final_population_list]

N, T = read_input()
final_population = genetic_algorithm_function(N, T)
random_parents = sample(final_population, 2)
print("\nParents:")
print("Parent 1:", random_parents[0])
print("Parent 2:", random_parents[1])
answers = two_p_crossover(random_parents[0], random_parents[1])
print("\nFollowing two-point crossover, the resultants offsprings are: ")
print("Offspring 1:", answers[0])
print("Offspring 2:", answers[1])</pre>
</body>
</html>
