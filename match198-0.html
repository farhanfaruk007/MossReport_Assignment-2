<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/5/20101030_lab2_sec5_-_FAIYAZ_HOSSAIN_RUSAD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/5/20101030_lab2_sec5_-_FAIYAZ_HOSSAIN_RUSAD.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20101030_Lab2_Sec5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DlucMEgDe9RCg2XIgcoouuD18WaiB98u
<a name="0"></a><font color="#FF0000"><a href="match198-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_26.gif"/></a>

"""

import random

# Input: Number of courses (N) and timeslots (T)
N = 3  # Number of courses
T = 3  # Number of timeslots
courses = ["CSE110", "MAT110", "PHY112"]

# Function to generate a random population
def generate_population(population_size, num_courses, num_timeslots):
    population = []
    for _ in range(population_size):
        chromosome = ''.join(random.choice('01') for _ in range(num_courses * num_timeslots))
        while '1' not in chromosome:  # Ensure at least one course is scheduled
            chromosome = ''.join(random.choice('01') for _ in range(num_courses * num_timeslots))
        population.append(chromosome)
    return population

# Function to calculate fitness of a chromosome
def calculate_fitness(chromosome, num_courses, num_timeslots):
    segments = [chromosome[i * num_courses:(i + 1) * num_courses] for i in range(num_timeslots)]
</font>    overlap_penalty = 0
    consistency_penalty = 0

    # Calculate overlap penalty
    for segment in segments:
        overlap_penalty += max(0, segment.count('1') - 1)

    # Calculate consistency penalty
    course_counts = [sum(int(segment[j]) for segment in segments) for j in range(num_courses)]
    consistency_penalty += sum(abs(count - 1) for count in course_counts)

    total_penalty = overlap_penalty + consistency_penalty
    fitness = -total_penalty
    return fitness

# Generate an initial population
population_size = 10
population = generate_population(population_size, N, T)

# Evaluate the fitness of each chromosome
fitness_values = [calculate_fitness(chromosome, N, T) for chromosome in population]

# Select the chromosome with the highest fitness
best_index = fitness_values.index(max(fitness_values))
best_chromosome = population[best_index]
best_fitness = fitness_values[best_index]

# Output the best solution
print("Best Chromosome:", best_chromosome)
print("Fitness Value:", best_fitness)

# Select two parents randomly from the population
<a name="1"></a><font color="#00FF00"><a href="match198-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

parent1, parent2 = random.sample(population, 2)

# Length of the chromosome
chromosome_length = len(parent1)

# Select two random points for crossover
point1 = random.randint(1, chromosome_length - 2)
point2 = random.randint(point1 + 1, chromosome_length - 1)

# Create children by swapping segments between the crossover points
child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
</font><a name="2"></a><font color="#0000FF"><a href="match198-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

# Output the parents and children
print("Parent 1:", parent1)
print("Parent 2:", parent2)
print("Crossover Points:", point1, point2)
print("Child 1:", child1)
print("Child 2:", child2)</font></pre>
</body>
</html>
