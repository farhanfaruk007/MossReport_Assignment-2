<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/8/24141238_cse422_lab_assignment_2_-_MUHAMMED_IRTIZA_MAHMOOD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/17/21301529_Muntasir_Hasan_Ahmed_CSE422_17_Assignment02_Fall2024_-_MUNTASIR_HASAN_AHMED.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301529_Muntasir Hasan Ahmed_CSE422_17_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZWCYCY4siUPNTWvPV-J09wN54qX0dCPB
"""

import random


def read_input(file_path):

    with open(file_path, 'r') as file:
        lines = file.readlines()

    print("File content read for debugging:")
    for line in lines:
        print(repr(line))

    num_courses, num_timeslots = map(int, lines[0].strip().split())

    print(f"Number of courses: {num_courses}, Number of timeslots: {num_timeslots}")

    courses = [lines[i].strip() for i in range(1, num_courses + 1)]
    return num_courses, num_timeslots, courses


NUM_COURSES, NUM_TIMESLOTS, COURSE_LIST = read_input('input.txt')
print(f"Courses: {COURSE_LIST}")


POPULATION_SIZE = 10
MAX_GENERATIONS = 100
ELITISM_RATE = 20

class Schedule:

    def __init__(self, genome):
        self.genome = genome
        self.fitness = self.evaluate_fitness()

    def evaluate_fitness(self):

        global NUM_COURSES, NUM_TIMESLOTS
        overlap_penalty = 0
        consistency_penalty = 0


        timeslot_allocations = [
            self.genome[i * NUM_COURSES:(i + 1) * NUM_COURSES]
            for i in range(NUM_TIMESLOTS)
        ]


<a name="1"></a><font color="#00FF00"><a href="match193-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

        for timeslot in timeslot_allocations:
            active_courses = timeslot.count('1')
            overlap_penalty += max(0, active_courses - 1)


        for course_idx in range(NUM_COURSES):
            occurrences = sum(1 for slot in timeslot_allocations if slot[course_idx] == '1')
            if occurrences != 1:
                consistency_penalty += abs(occurrences - 1)


        return -(overlap_penalty + consistency_penalty)

    @staticmethod
</font>    def generate_random_genome(length):

        return Schedule(''.join(random.choice('01') for _ in range(length)))

<a name="2"></a><font color="#0000FF"><a href="match193-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    def mutate(self, mutation_rate=0.01):

        genome_list = list(self.genome)
        for i in range(len(genome_list)):
            if random.random() &lt; mutation_rate:
                genome_list[i] = '0' if genome_list[i] == '1' else '1'
        return Schedule(''.join(genome_list))
</font>
    def crossover(self, partner):

        crossover_point = random.randint(1, len(self.genome) - 1)
<a name="0"></a><font color="#FF0000"><a href="match193-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

        child1_genome = self.genome[:crossover_point] + partner.genome[crossover_point:]
        child2_genome = partner.genome[:crossover_point] + self.genome[crossover_point:]
        return Schedule(child1_genome), Schedule(child2_genome)


def select_parents(population):

    total_fitness = sum(chromosome.fitness for chromosome in population)
    probabilities = [chromosome.fitness / total_fitness for chromosome in population]
</font>    return random.choices(population, probabilities, k=2)


def run_genetic_algorithm():

    global NUM_COURSES, NUM_TIMESLOTS
    population = [Schedule.generate_random_genome(NUM_COURSES * NUM_TIMESLOTS) for _ in range(POPULATION_SIZE)]

    print("Initial population created.")

    for generation in range(MAX_GENERATIONS):

        population.sort(key=lambda x: x.fitness, reverse=True)


        num_elites = int(ELITISM_RATE * POPULATION_SIZE / 100)
        new_generation = population[:num_elites]


        while len(new_generation) &lt; POPULATION_SIZE:
            parent1, parent2 = select_parents(population)
            child1, child2 = parent1.crossover(parent2)
            new_generation.append(child1.mutate())
            if len(new_generation) &lt; POPULATION_SIZE:
                new_generation.append(child2.mutate())

        population = new_generation


        print(f"Generation {generation + 1}: Best Fitness = {population[0].fitness}, Best Genome = {population[0].genome}")


    best_solution = max(population, key=lambda x: x.fitness)
    print(f"Final Solution: Genome = {best_solution.genome}, Fitness = {best_solution.fitness}")

if __name__ == "__main__":
    run_genetic_algorithm()</pre>
</body>
</html>
