<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/15/22101446_MD_Touhidur_Rahman_CSE422_15_Lab_Assignment02_Fall2024_-_MD_TOUHIDUR_RAHMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/16/24141248_cse422_section16_labassignment2_-_GOLAM_MOHAMMAD_RAHI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""ID-24141248_CSE422_Section16_LabAssignment2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qicgSkbP_AEcO9DGlTUGfxJoBXCJg9nT
"""

import random
import numpy as np
def create_initial_population(population_size, num_courses, num_timeslots):
    initial_population = []
    i = 0

    while i &lt; population_size:
        individual = []
        j = 0
<a name="1"></a><font color="#00FF00"><a href="match163-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

        while j &lt; num_timeslots:
            timeslot_allocation = [0] * num_courses
            selected_courses = random.sample(range(num_courses), k=random.randint(1, num_courses))
            for course in selected_courses:
                timeslot_allocation[course] = 1
            individual.extend(timeslot_allocation)
            j += 1
</font>        initial_population.append(individual)
        i += 1
    return initial_population




def calculate_fitness(individual, num_courses, num_timeslots):
    overlap_penalty = 0
    consistency_penalty = 0
    schedule_matrix = np.reshape(individual, (num_timeslots, num_courses))
    i = 0
    while i &lt; num_timeslots:
        timeslot = schedule_matrix[i]
        courses_in_timeslot = sum(timeslot)
        if courses_in_timeslot &gt; 1:
            overlap_penalty += courses_in_timeslot - 1
        i += 1

    course_occurrences = np.sum(schedule_matrix, axis=0)
    i = 0
    while i &lt; len(course_occurrences):
        if course_occurrences[i] != 1:
            consistency_penalty += abs(course_occurrences[i] - 1)
        i += 1

    total_penalty = overlap_penalty + consistency_penalty
    return -total_penalty


<a name="0"></a><font color="#FF0000"><a href="match163-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

def probabilistic_selection(population, fitness_scores):
    total_fitness = sum(fitness_scores)
    selection_probabilities = [fitness / total_fitness for fitness in fitness_scores]
    chosen_index = np.random.choice(len(population), p=selection_probabilities)
    return population[chosen_index]


def perform_crossover(parent_a, parent_b):
    crossover_point = random.randint(1, len(parent_a) - 1)
    offspring_a = parent_a[:crossover_point] + parent_b[crossover_point:]
</font>    offspring_b = parent_b[:crossover_point] + parent_a[crossover_point:]
    return offspring_a, offspring_b

def apply_mutation(individual, mutation_chance):
    i = 0
    while i &lt; len(individual):
        if random.random() &lt; mutation_chance:
            individual[i] = 1 - individual[i]
        i += 1
<a name="4"></a><font color="#FF00FF"><a href="match163-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    return individual


def genetic_schedule_optimizer(courses_list, num_courses, num_timeslots, population_size=100, generations=1000, mutation_chance=0.01):
    population = create_initial_population(population_size, num_courses, num_timeslots)
    optimal_fitness = float('-inf')
</font>    optimal_schedule = None
    generation = 0
    while generation &lt; generations:
        fitness_scores = []
        i = 0
        while i &lt; len(population):
            fitness_scores.append(calculate_fitness(population[i], num_courses, num_timeslots))
            i += 1

<a name="3"></a><font color="#00FFFF"><a href="match163-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

        best_fitness_in_gen = max(fitness_scores)
        best_index_in_gen = fitness_scores.index(best_fitness_in_gen)

        if best_fitness_in_gen &gt; optimal_fitness:
            optimal_fitness = best_fitness_in_gen
            optimal_schedule = population[best_index_in_gen]

        if optimal_fitness == 0:
            break

        next_generation = []
</font>        i = 0
<a name="2"></a><font color="#0000FF"><a href="match163-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        while i &lt; (population_size // 2):
            parent_a = probabilistic_selection(population, fitness_scores)
            parent_b = probabilistic_selection(population, fitness_scores)
            offspring_a, offspring_b = perform_crossover(parent_a, parent_b)
            offspring_a = apply_mutation(offspring_a, mutation_chance)
            offspring_b = apply_mutation(offspring_b, mutation_chance)
            next_generation.extend([offspring_a, offspring_b])
</font>            i += 1

        population = next_generation
        generation += 1

    return optimal_schedule, optimal_fitness

<a name="5"></a><font color="#FF0000"><a href="match163-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

with open('input.txt', 'r') as file:
    first_line = file.readline().strip().split()
    num_courses = int(first_line[0])
    num_timeslots = int(first_line[1])
</font>    courses_list = []
    i = 0
    while i &lt; num_courses:
        courses_list.append(file.readline().strip())
        i += 1

optimized_schedule, best_fitness = genetic_schedule_optimizer(courses_list, num_courses, num_timeslots)
schedule_as_string = ''.join(map(str, optimized_schedule))
print(schedule_as_string)
print(best_fitness)

import random
def create_population(pop_size, gene_length):
    population_group = []
    i = 0
    while i &lt; pop_size:
        chromosome = []
        j = 0
        while j &lt; gene_length:
            chromosome.append(random.randint(0, 1))
            j += 1
        population_group.append(chromosome)
        i += 1
    return population_group

def perform_crossover(donor1, donor2):

    seq_length = len(donor1)
    part1 = random.randint(1, seq_length - 2)
    part2 = random.randint(part1 + 1, seq_length - 1)
    children1 = donor1[:part1] + donor2[part1:part2] + donor1[part2:]
    children2 = donor2[:part1] + donor1[part1:part2] + donor2[part2:]
    print(f"1st crossover part: Between index {part1 - 1} and index {part1}")
    print(f"2nd crossover part: Between index {part2 - 1} and index {part2}")

    return children1, children2

population_size = 10
chromosome_length = 9
initial_population = create_population(population_size, chromosome_length)
parent_a = random.choice(initial_population)
parent_b = random.choice(initial_population)
children_a, children_b = perform_crossover(parent_a, parent_b)
print("Parent A:", ''.join(map(str, parent_a)))
print("Parent B:", ''.join(map(str, parent_b)))
print("Children A: ", ''.join(map(str, children_a)))
print("Children B: ", ''.join(map(str, children_b)))</pre>
</body>
</html>
