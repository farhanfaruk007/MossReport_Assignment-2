<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/15/22101660_sadia_nawshin_cse422_15_lab_assignment02_fall2024_-_SADIA_NAWSHIN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/15/22101660_sadia_nawshin_cse422_15_lab_assignment02_fall2024_-_SADIA_NAWSHIN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101660_Sadia_Nawshin_CSE422_15_Lab_Assignment02_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X4cc7otByRUoVFthZ1x3JY67rhcJ2j7B
"""

#task01
import random

f = open("CSE422_01_Lab_Assignment02_GeneticAlgorithm_Input.txt","r")
input = f.readline()
N , T = input.split()
N = int(N)
T = int(T)
courses = []
for i in range(N):
    input = f.readline()
    courses.append(input.strip())

def overlap_penalty(schedule, N, T):
    overlap_penalty = 0
    for i in range(T):
        start = i * N
        end = (i+1) * N
        each_timeslot = schedule[start : end]
        extra_course_slot = 0
<a name="0"></a><font color="#FF0000"><a href="match157-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

        for j in each_timeslot:
            if j == "1":
                extra_course_slot += 1
        if extra_course_slot &gt; 1:
            overlap_penalty += extra_course_slot - 1
    return overlap_penalty

def consistency_penalty(schedule, N, T):
    penalty = 0
    for i in range(N):
        schedule_check = 0
        for j in range(T):
            index = j * N + i #
            schedule_check += int(schedule[index])
        if schedule_check != 1:
            penalty += abs(schedule_check - 1)
    return penalty

def fitness(schedule, N, T):
    overlapping_penalty = overlap_penalty(schedule, N, T)
    con_penalty = consistency_penalty(schedule, N, T)
    fitness = -(overlapping_penalty + con_penalty)
    return fitness

def random_parents_selection(population, N, T):
    parent1 = random.choice(population)
</font>    parent2 = random.choice(population)
    return parent1, parent2

def crossover(parent1, parent2, N, T):
    crossover_point = random.randint(1, T * N - 1)
    crossover1 = parent1[:crossover_point] + parent2[crossover_point:]
    crossover2 = parent2[:crossover_point] + parent1[crossover_point:]
    return crossover1, crossover2

def mutation(schedule, N, T):
    mutation_index = random.randint(0, T * N - 1)
<a name="3"></a><font color="#00FFFF"><a href="match157-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    mutation_schedule = list(schedule)
    if mutation_schedule[mutation_index] == "1":
       mutation_schedule[mutation_index] = "0"
    else:
        mutation_schedule[mutation_index] = "1"
    mutated = "".join(mutation_schedule)
</font>    return mutated

def create_population(N, T, population_size):
    population = []
    for i in range(population_size):
        individual_population = []
        for j in range(N * T):
            individual_population.append(str(random.randint(0,1)))
        population.append("".join(individual_population))
    return population

def genetic_algorithm(N, T, population_size, max_iteration):
    population = create_population(N, T, population_size)
    for i in range(max_iteration):
        new_population = []
        population_size = population_size // 2
<a name="2"></a><font color="#0000FF"><a href="match157-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        for j in range(population_size):
            parent1, parent2 = random_parents_selection(population, N, T)
            crossover_child1, crossover_child2 = crossover(parent1, parent2, N, T)
            mutated_child1 = mutation(crossover_child1, N, T)
            mutated_child2 = mutation(crossover_child2, N, T)
</font>            new_population.extend([mutated_child1, mutated_child2])
<a name="1"></a><font color="#00FF00"><a href="match157-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

        population = new_population
        fitness_check = []
        for schedule in population:
            new = fitness(schedule, N ,T)
            fitness_check.append(new)
        maximum_fitness = max(fitness_check)
        best_schedule_index = fitness_check.index(maximum_fitness)
        best_schedule = population[best_schedule_index]
        if max(fitness_check) == 0:
            break
    return best_schedule, max(fitness_check)
</font>
if T &lt;= N:
    best_schedule, highest_fitness = genetic_algorithm(N, T, 100, 1000)
    print(best_schedule)
    print(highest_fitness)

else:
    print("N must be less than T")

#task02
import random

f = open("CSE422_01_Lab_Assignment02_GeneticAlgorithm_Input.txt","r")
input = f.readline()
N , T = input.split()
N = int(N)
T = int(T)
courses = []
for i in range(N):
    input = f.readline()
    courses.append(input.strip())

def overlap_penalty(schedule, N, T):
    overlap_penalty = 0
    for i in range(T):
        start = i * N
        end = (i+1) * N
        each_timeslot = schedule[start : end]
        extra_course_slot = 0
        for j in each_timeslot:
            if j == "1":
                extra_course_slot += 1
        if extra_course_slot &gt; 1:
            overlap_penalty += extra_course_slot - 1
    return overlap_penalty

def consistency_penalty(schedule, N, T):
    penalty = 0
    for i in range(N):
        schedule_check = 0
        for j in range(T):
            index = j * N + i
            schedule_check += int(schedule[index])
        if schedule_check != 1:
            penalty += abs(schedule_check - 1)
    return penalty

def fitness(schedule, N, T):
    overlapping_penalty = overlap_penalty(schedule, N, T)
    con_penalty = consistency_penalty(schedule, N, T)
    fitness = -(overlapping_penalty + con_penalty)
    return fitness

def random_parents_selection(population, N, T):
    parent1 = random.choice(population)
    parent2 = random.choice(population)
    return parent1, parent2

def crossover(parent1, parent2, N, T):
    crossover_point = random.randint(1, T * N - 2)
    crossover_point2 = random.randint(crossover_point + 1, T * N - 1)
    crossover1 = parent1[:crossover_point] + parent2[crossover_point:crossover_point2] + parent1[crossover_point2:]
    crossover2 = parent2[:crossover_point] + parent1[crossover_point:crossover_point2] +parent2[crossover_point2:]
    return crossover1, crossover2

def mutation(schedule, N, T):
    mutation_index = random.randint(0, N * T - 1)
    mutation_schedule = list(schedule)
    if mutation_schedule[mutation_index] == "1":
       mutation_schedule[mutation_index] = "0"
    else:
        mutation_schedule[mutation_index] = "1"
    mutated = "".join(mutation_schedule)
    return mutated

def create_population(N, T, population_size):
    population = []
    for i in range(population_size):
        individual_population = []
        for j in range(N * T):
            individual_population.append(str(random.randint(0,1)))
        population.append("".join(individual_population))
    return population

def genetic_algorithm(N, T, population_size, max_iteration):
    population = create_population(N, T, population_size)
    for i in range(max_iteration):
        new_population = []
        population_size = population_size // 2
        for j in range(population_size):
            parent1, parent2 = random_parents_selection(population, N, T)
            crossover_child1, crossover_child2 = crossover(parent1, parent2, N, T)
            mutated_child1 = mutation(crossover_child1, N, T)
            mutated_child2 = mutation(crossover_child2, N, T)
            new_population.extend([mutated_child1, mutated_child2])
        population = new_population
        fitness_check = []
        for schedule in population:
            new = fitness(schedule, N ,T)
            fitness_check.append(new)
        maximum_fitness = max(fitness_check)
        best_schedule_index = fitness_check.index(maximum_fitness)
        best_schedule = population[best_schedule_index]
        if max(fitness_check) == 0:
            break
    return best_schedule, max(fitness_check)

if T &lt;= N:
    best_schedule, highest_fitness = genetic_algorithm(N, T, 100, 1000)
    print(best_schedule)
    print(highest_fitness)

else:
    print("N must be less than T")</pre>
</body>
</html>
