<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/9/22101047_SaadmanBinJashim_22101047_-_SAADMAN_BIN_JASHIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab2_Submission/14/21301680_cse422_section_14_labassignment2_pylll_-_KHAN_MOHAMMAD_AL_KAREEB.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301680_CSE422_Section-14_LabAssignment2.pylll

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ja60ZS8eGjJ7YV888AQgGRQWQpLNnDl5
"""

# TASK1


import random

def generate_initial_population(unique_count_course, scheduling_timeslots, population_size=100):
   genetic_pool = []
   population_index = 0
   while population_index &lt; population_size:
       sequence_chrom = []
       gene_index = 0
       while unique_count_course * scheduling_timeslots &gt; gene_index:
           sequence_chrom.append(random.randint(0, 1))
           gene_index += 1
       genetic_pool.append(sequence_chrom)
       population_index += 1
   return genetic_pool

def apply_mutation(sequence_chrom, mutation_probability=0.5):
   gene_position = 0
   while gene_position &lt; len(sequence_chrom):
       if random.random() &lt; mutation_probability:
           sequence_chrom[gene_position] = 1 - sequence_chrom[gene_position]
       gene_position += 1
   return sequence_chrom

def perform_crossover(genetic_parent_a, genetic_parent_b):
   crossover_point = random.randint(1, len(genetic_parent_a) - 1)
   offspring_a = genetic_parent_a[:crossover_point] + genetic_parent_b[crossover_point:]
   offspring_b = genetic_parent_b[:crossover_point] + genetic_parent_a[crossover_point:]
   return offspring_a, offspring_b

def evaluate_fitness(sequence_chrom, unique_count_course, scheduling_timeslots):
   scheduling_overlap_penalty = 0
   scheduling_iteration = 0
   while scheduling_iteration &lt; scheduling_timeslots:
       timeslot_segment = sequence_chrom[scheduling_iteration * unique_count_course:(scheduling_iteration + 1) * unique_count_course]
       simultaneous_courses = sum(timeslot_segment)
       if simultaneous_courses &gt; 1:
           scheduling_overlap_penalty += (simultaneous_courses - 1)
       scheduling_iteration += 1

   course_allocation_tracking = [0] * unique_count_course
   index_course = 0
   while index_course &lt; unique_count_course:
       timeslot_index = 0
       while timeslot_index &lt; scheduling_timeslots:
           course_allocation_tracking[index_course] += sequence_chrom[timeslot_index * unique_count_course + index_course]
           timeslot_index += 1
       index_course += 1

   allocation_deviation_penalty = sum(abs(allocation - 1) for allocation in course_allocation_tracking)
<a name="2"></a><font color="#0000FF"><a href="match196-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

   total_scheduling_penalty = scheduling_overlap_penalty + allocation_deviation_penalty
   return -total_scheduling_penalty

def select_parent_population(population, fitness_scores, parent_count):
   ranked_population = sorted(zip(population, fitness_scores), key=lambda x: x[1], reverse=True)[:parent_count]
</font>   selected_parents = [individual for individual, _ in ranked_population]
<a name="1"></a><font color="#00FF00"><a href="match196-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

   return selected_parents

def execute_genetic_optimization(unique_count_course, scheduling_timeslots, generation_limit=100, population_size=100, parent_selection_count=50):
   genetic_population = generate_initial_population(unique_count_course, scheduling_timeslots, population_size)
   for _ in range(generation_limit):
       fitness_evaluations = [evaluate_fitness(chromosome, unique_count_course, scheduling_timeslots) for chromosome in genetic_population]
</font><a name="0"></a><font color="#FF0000"><a href="match196-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

       parent_selection = select_parent_population(genetic_population, fitness_evaluations, parent_selection_count)
       next_generation = []
       while len(next_generation) &lt; population_size:
           parent_a, parent_b = random.sample(parent_selection, 2)
           offspring_1, offspring_2 = perform_crossover(parent_a, parent_b)
           offspring_1 = apply_mutation(offspring_1)
           offspring_2 = apply_mutation(offspring_2)
           next_generation.append(offspring_1)
           if len(next_generation) &lt; population_size:
               next_generation.append(offspring_2)
       genetic_population = next_generation

   optimal_chromosome = max(genetic_population, key=lambda c: evaluate_fitness(c, unique_count_course, scheduling_timeslots))
   optimal_fitness = evaluate_fitness(optimal_chromosome, unique_count_course, scheduling_timeslots)
   return "".join(map(str, optimal_chromosome)), optimal_fitness

n, t = map(int, input("Enter the number of list_of_course and t_timing  (N T): ").split())
</font>list_of_course = [input(f"Enter course code for course {y + 1}: ") for y in range(n)]

print("\nInput Courses:", list_of_course)
print(f"Number of Courses: {n}")
print(f"Number of Timeslots: {t}")

optimal_schedule, fitness_score = execute_genetic_optimization(n, t)
print(f"\nOptimal Schedule: {optimal_schedule}")
print(f"Fitness Score: {fitness_score}")



# TASK 2

import random

def crossover_two_points(individual_set_a, individual_set_b):
    index_start = random.randint(0, len(individual_set_a) - 1)
    index_end = random.randint(index_start + 1, len(individual_set_a))

    offspring_a = individual_set_a[:index_start] + individual_set_b[index_start:index_end] + individual_set_a[index_end:]
    offspring_b = individual_set_b[:index_start] + individual_set_a[index_start:index_end] + individual_set_b[index_end:]

    return offspring_a, offspring_b

input_file = "input2.txt"
with open(input_file, 'r') as data_file:
    individual_set_a, individual_set_b = data_file.read().split()

new_child_a, new_child_b = crossover_two_points(individual_set_a, individual_set_b)

print(f"Individual Set A: {individual_set_a}")
print(f"Individual Set B: {individual_set_b}")
print(f"New Offspring A: {new_child_a}")
print(f"New Offspring B: {new_child_b}")</pre>
</body>
</html>
